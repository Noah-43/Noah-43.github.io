---
title: 실용주의_프로그래머_Chap6
excerpt: 실용주의 프로그래머 책 6장 정리
categories: study
---
# 6장. 코딩하는 동안 해야 할 일들

## 31. 우연에 맡기는 프로그래밍

우리는 우연에 맡기는 프로그래밍, 즉 행운과 어쩌다 오는 성공에 의존하는 프로그래밍을 하지 말아야 한다. 대신 의도적으로 프로그래밍 해야 한다. 우연적 구현(accidents of implementation)은 단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 일들을 가리킨다. 결국에는 문서화되지 않은 에러나 입력 값이 특정한 조건에서만 돌아가는 경우와 마주치게 된다. 우연적 맥락(accidents of context)도 마찬가지로 생길 수 있다. 요구사항을 만들어 내는 것부터 테스트에 이르기까지 어떤 레벨에서든 우연은 우리를 잘못된 길로 이끌 수 있다. 가정하지 말자. 증명하자. 확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.

우리는 되도록 개발 주기의 이른 시기에 코드를 뒤져 에러를 발견하고 고쳐 시간을 절약하고 싶다. 애초부터 에러를 적게 만들면 더 좋다. 이때 의도적으로 프로그래밍하는 것이 도움이 된다. 그렇다면 의도적 프로그래밍은 어떻게 해야 할까.

- 언제나 자기가 지금 무엇을 하고 있는지 알아야 한다.
- 맹목적으로 코딩하지 말자.
- 계획을 세우고 그것을 바탕으로 진행하자.
- 신뢰할 수 있는 것에만 기대자.
- 가정을 문서로 남기자.
- 코드만 테스트할 것이 아니라 세운 가정도 테스트하자.
- 노력을 기울일 대상의 우선순위를 정하자
- 과거의 노예가 되지 말자. 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말자.

앞으로 어떤 것이 잘 돌아가는 것처럼 보이기는 하는데 그 이유를 모를 경우, 그것이 우연은 아닌지 반드시 확인하도록 하자.



## 32. 알고리즘의 속도

우리는 알고리즘이 사용하는 자원. 시간, 프로세서, 메모리 등을 추정해야 한다. 일반적으로 입력의 크기가 클수록, 알고리즘의 수행시간이 길어지거나 사용하는 메모리 양이 늘어난다. 이런 관계들이 선형적일 수 있으나 대부분 선형적이지 않다. 우리는 수행시간과 메모리 요구량을 상세히 분석하기 위해서 O() 표기법을 사용할 수 있다. O() 표기법은 근사값을 다루기 위한 수학적 방법이다. 예를 들어 어떤 함수가 O(n^2) 시간이 걸린다고 하면, 이 함수가 실행되는 데 걸리는 시간의 최대값이 n^2 보다 더 빨리 늘어나지 않는다는 뜻이다. O() 표기법은 시간에만 적용되지 않으며, 알고리즘이 사용하는 다른 어떤 자원(ex. 메모리 소비 모델링)을 나타낼 때도 이 표기법을 쓸 수 있다.

상식을 이용해서 수많은 간단한 알고리즘들의 차수를 추정할 수 있다.

- 간단한 반복문 - O(n)
- 겹친 반복문 - O(n^2)
- 반씩 잘라 나가기 - O(lg(n))
- 나눠서 정복하기(divide and conquer) - O(nlg(n)), 퀵정렬(의 평균 수행시간)
- 조합적(combinatoric) - O(n!)

자주 쓰이는 O() 표기법들

- O(1) - 상수적 (배열의 원소 접근, 단순 명령문)
- O(lg(n)) - 대수적 (이진 검색)
- O(n) - 선형적 (순차 검색)
- O(nlg(n)) - 선형적보다는 좋지 않지만, 그래도 그렇게 많이 나쁘지는 않음. (퀵정렬, 힙정렬의 평균 수행시간)
- O(n^2) - 제곱적 (선택 정렬과 삽입 정렬)
- O(n^3) - 세제곱적 (두 n x n 행렬의 곱)
- O(C^n) - 지수적 (여행하는 판매원 문제, 집합 분할)

알고리즘을 실행할 때 들어가는 숫자가 수행시간이나 메모리 소비에 어떤 영향을 미칠지 생각해보자. 알고리즘의 차수를 추정하자. 그리고 그 추정을 테스트하자. 단순한 O(n^2) 코드가 복잡한 O(nlg(n)) 코드보다 더 좋은 성능을 내기도 한다. 알고리즘 선택은 실용적이어야 한다. 가장 빠른 알고리즘이 언제가 가장 좋은 알고리즘은 아니다. 성급한 최적화를 주의하자.



## 33. 리팩터링

코드를 다시 작성하기, 다시 작업하기, 다시 설계하기를 총괄해서 '리팩터링'이라고 한다. 그럼 어떤 것들에 리팩터링이 필요할까.

- 중복
- 직교성이 좋지 않은 설계
- 유효기간이 끝난 지식
- 성능

핑계를 대며 리팩터링을 미루는 것은 좋지 않다. 나중이 되면 리팩터링에 드는 비용도 커지고 위험도 훨씬 커진다. 그러니 일찍 리팩터링하고, 자주 리팩터링하자. 리팩터링이 필요한 것들의 목록을 만들고 유지하자. 당장 리팩터링이 힘들다면 일정에 리팩터링할 시간을 확실히 포함시키자.

리팩터링의 본질은 재설계다. 설계해 둔 모든 것은 요구사항이 바뀌거나 문제가 생기면 언제라도 재설계의 대상이 될 수 있다. 하지만 규모가 큰 코드에서 무지성으로 리팩터링을 진행하면 리팩터링하기 전보다 망할 수 있다. 리팩터링은 천천히, 신중하게, 조심스럽게 진행해야 한다. 다음의 조언을 잘 새겨두자.

1. 리팩터링과 새로운 기능 추가를 동시에 하지 말자.
2. 리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 먼저 확인하고, 할 수 있는 한 자주 테스트들을 돌려본다.
3. 단계를 작게 나누어서 신중하게 작업한다.



## 34. 테스트하기 쉬운 코드

소프트웨어 단위 테스트란 어떤 모듈에게 이것저것을 시켜보는 코드를 가리킨다. 일반적으로, 단위 테스트는 일종의 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴들을 호출한다. 그런 다음 반환된 결과들을 이미 알고 있는 값과 비교해 보거나 똑같은 테스트를 이전에 돌렸을 때 나온 값과 비교해(회귀 테스트, regression testing) 올바른지 검사한다. 우리는 단위 테스트를 계약을 잘 지키는지 보는 테스트로 사용한다. 이런 테스트는 코드가 계약을 지키는 여부와 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치하는지를 알려준다.

모듈을 설계할 때는, 그것이 지켜야 할 계약과 계약을 지키는지 테스트하는 코드도 함께 설계해야 한다. 테스트를 통과하고 계약을 지키는 코드를 설계하다 보면 자연스럽게 그렇게 설계하지 않았으면 생각나지 않았을 경계 조건이나 다른 문제들을 고려하게 된다. 모듈의 단위 테스트는 찾기 편한 곳에 위치해야 한다. 테스트 코드를 쉽게 접근할 수 있게 해 놓는 것은 다음과 같은 자원이 된다.

1. 모듈의 모든 기능을 어떻게 이용해야 하는지 보여주는 예제
2. 코드 변경 시 검증하기 위한 회귀 테스트를 구축할 수 있는 수단

테스트 장치는 상태를 기록으로 남기거나, 예상 결과값에 비추어 출력을 분석하거나, 테스트를 선택하고 실행하는 일처럼 자주 쓰이는 작업들을 다룰 수 있어야 한다. 객체지향 언어와 환경에서는, 이런 공통적인 기능을 제공하는 기반 클래스를 만들곤 한다. 개별 테스트들은 이 기반 클래스에게서 상속받아 구체적인 테스트 코드를 추가하면 된다. 테스트는 조립식으로 작동할 수 있어야 한다. 어떤 테스트 장치를 사용하든, 테스트 장치라면 반드시 다음과 같은 기능이 있어야 한다.

- 시작할 때 할 일과 마칠 때 할 일을 지정할 수 있는 표준적인 방법
- 개별적인 테스트들을 선택하거나, 아니면 모든 테스트를 한꺼번에 선택하게 해주는 메서드
- 예상한 (또는 예상하지 못한) 결과에 비추어 결과를 분석할 수 있는 방법
- 실패를 보고하는 표준화된 형태

소프트웨어가 배치된 후에도 테스트해야만 하는 경우가 발생한다. 추적 메시지를 담아 두는 로그 파일로 내부 상태를 확인할 수 있다. 로그 메시지는 규칙적이고 일관된 형식이어야 한다. 또는 '단축키(hot-key)'를 제공해 상태 정보와 그 외 것들이 들어있는 진단 제어창이 열리게 만드는 방법도 있다. 규모가 크고 더 복잡한 서버 코드라면, 웹 서버를 내장시키는 것이 작업 상태를 점검하는 수단을 제공하는 멋진 기법이 될 수 있다.



## 35. 사악한 마법사

우리는 몇 가지 간단한 질문에만 대답하면, 마법사가 자동으로 만들어주는 골격 코드를 얻을 수 있다. 하지만 자신을 위해 만들어진 코드를 정말로 이해하지 못하는 한 그것은 자기 자신을 속이는 것이다. 해당 코드가 지금 상황에 맞지 않거나 상황이 바뀌어서 코드를 변경해야 할 필요가 생긴다면, 그때는 자신의 힘으로 해결해야 한다. 그러니 자신이 이해하지 못했다면, 그 코드를 사용해서는 안된다. 그 애플리케이션을 유지보수하지도 못할 것이고, 디버깅 할 때 고생할 것이다. 

