---
title: 실용주의_프로그래머_Chap8
excerpt: 실용주의 프로그래머 책 8장 정리
categories: study
---

# 8장. 실용주의 프로젝트

## 41. 실용주의 팀

팀 전체에 실용주의 기법을 어떻게 적용할 수 있을까.

- 깨진 창문을 없애자. 품질은 팀의 이슈다. 팀 전체가 깨진 창문을 용납하지 않아야 한다. 팀은 상품의 품질에 대해 책임을 져야 한다. 품질은 팀원 '전체'가 개인적으로 기여할 때만 보장된다.
- 팀의 모든 사람이 적극적으로 환경 변화를 감시해야 한다. 사람들은 누군가가 문제를 처리하겠거니 생각하거나, 사용자가 요구하는 변화에 대해 팀 리더가 이미 오케이 했거니 하고 여긴다. 제아무리 단단히 통제되는 팀이라도 프로젝트가 심각하게 변화하는 것에 대해 둔감할 수 있다. 범위의 확장, 시간 척도의 감소, 추가 기능, 새로운 환경 등 무엇이건 간에 합의사항에 있지 않던 것들을 항상 점검하자. 이미 일어난 변화를 거부할 필요는 없다. 그런 일이 벌어지고 있다는 것을 알고 있으면 된다.
- 소통하자. 팀은 나머지 세상과 명확히 의사소통해야 할 필요가 있는 존재다. 훌륭한 프로젝트 팀은 뚜렷한 특성을 갖는다. 모든 사람이 좋아할 만한 잘 준비된 퍼포먼스를 보게 될 걸 알기 때문에 사람들은 회의를 기대한다. 그들이 생상해 내는 문서는 깔끔하고 정확하며 일관적이다. 팀은 한 목소리로 이야기한다.
- 반복하지 말자. 중복은 노력을 낭비하게하고, 유지보수를 어렵게 한다. 여기에는 훌륭한 의사소통이 분명 도움이 된다. 하지만 그 외에도 다른 것이 필요한 경우가 있다. 문서와 코드를 관리할 때 한 사람이 맡아서 중복을 제거 관리 하는 것도 좋다. 프로젝트의 크기가 너무 크다면 작업의 다양한 기능적 측면의 핵심 사안별로 나눠서 관리하자.
- 팀을 기능 중심으로 조직하자. 프로젝트의 여러 활동(분석, 설계, 코딩, 테스팅)이 독립적으로 이루어지는 것은 불가능하다. 그것들은 동일한 문제의 다른 관점일 뿐이다. 사람들을 작은 팀으로 나누고, 각 팀은 최종 시스템의 특정한 기능 측면에 대해 책임지도록 하자. 기능 중심으로 팀을 조직하면 계약이나 결합도 줄이기 같은 코드를 조직할 때 쓰는 기법으로 자원을 조직할 수 있다. 어떤 변화가 생겼을 때 전체가 영향받는 일이 없게 된다.
- 일관성과 정확성을 보장하는 훌륭한 방법은 팀이 하는 모든 일을 자동화하는 것이다. 자동화는 모든 프로젝트 팀에게 필요불가결한 요소다. 자동화를 보장받기 위해 도구 제작자 역할을 위임해 makefile, 셸 스크립트, 에디터 템플릿, 유틸리티 프로그램 등을 만들게 하자.
- 팀은 개인들로 이루어진다는 사실을 명심하자. 각 팀원이 자신의 방식대로 빛날 수 있도록 하여, 프로젝트가 요구사항에 맞게 이루어질 구조를 제공하자.



## 42. 유비쿼터스 자동화

우리는 프로젝트에서 일관성과 반복가능성을 확보하고 싶다. 수작업이란 것은 일관성을 운에 맡긴다. 반복가능성을 보장받지 못한다. 특히 그 과정이 여러 사람에 의해 달리 해석될 여지가 있다면 더더욱 그렇다. 수작업 절차를 사용하지 말자. 셸 스크립트나 배치 파일은 동일한 명령들을 매번 똑같은 순서로 수행한다. 이걸 소스코드 관리 시스템에서 관리할 수 있기 때문에 시간이 지남에 따라 그 절차가 어떻게 변했는지도 조사할 수 있다.

프로젝트 컴파일은 믿을 만하고 반복가능하게 만들어야 한다. 우리는 보통 makefile로 프로젝트를 컴파일 하고, 여기에는 몇가지 장점이 있다. 스크립트로 된 자동 과정이고, 우리가 사용할 코드를 생성하게 할 수도 있고, 회귀 테스트를 자동실행시킬 수도 있다. 우리는 명령 하나로 확인, 빌드, 테스트, 출하를 할 수 있다.

빌드는 비어 있는 디렉터리 하나를 가지고 프로젝트를 밑바닥에서부터 만드는 과정으로 우리가 생산해 내고 싶은 것을 최종적으로 생산한다. 대개의 빌드는 개인이 프로젝트의 특정 부분을 빌드하는 동안 실행하는 테스트보다 더 완전한 테스트들을 실행한다. 코드 변화로 회귀 테스트가 실패할지 아닐지 알고 소스에 가깝게 문제를 찾아냄으로써, 그걸 찾고 고칠 확률은 더 높아진다.

우리는 더 나은 도구를 만들기 위해 필요한 것들을 갖고 있다. cron, make를 사용하자. 그리고 펄이나 고차원 스크립트 언어로 맞춤 도구나 웹 페이지 생성기, 코드 생성기, 테스트 장치 등을 빨리 개발할 수 있다. 반복적이고 지루한 작업은 컴퓨터에게 시키자. 컴퓨터가 더 잘 한다.



## 43. 가차 없는 테스트

개발자 대부분은 테스트를 싫어하지만, 코드를 작성하자마자 테스트해야 한다. 일찍 테스트하고, 자주 테스트하고, 자동으로 테스트 해야 한다. 버그가 빨리 발견될수록 고치는 비용이 적어진다. 테스트를 통과했다는 것은 그 코드가 '완료되었다'고 말할 수 있는 높은 수준의 확신을 갖게 한다. 모든 테스트가 통과하기 전엔 코딩이 다 된 게 아니다.

소프트웨어 테스트에는 대여섯 가지 주요 유형이 있다.

- 단위 테스트 - 하나의 모듈을 테스트
- 통합 테스트 - 프로젝트를 구성하는 주요 서브시스템이 다른 부분과 제대로 작동하는지 테스트
- 유효성 평가(validation)와 검증(verification) - 시스템의 기능적 요구사항을 충족하는지 테스트
- 자원 고갈, 에러, 그리고 복구 - 메모리, 디스크 공간, CPU 대역폭, 벽시계 시간(wall-clock time), 디스크 대역폭, 네트워크 대역폭, 칼라 팔레트, 비디오 해상도 등의 제한 사항으로 인해 발생하는 실패 및 복구 테스트
- 성능(performance) 테스트 - 소프트웨어가 실세계 조건에서 성능 요구사항들을 만족하는지 테스트.
- 사용편의성(usability) 테스트 - 실제 환경의 조건 하에서 실제 사용자들이 시행하는 테스트

그렇다면 테스트는 어떻게 해야할까?

- 회귀 테스트 - 이전 값과 현재 테스트의 출력을 비교. 성능, 계약, 유효성 등을 검증하기 위해 회귀 테스트를 실행
- 테스트 데이터 - 실세계 데이터와 합성 데이터. 실세계 데이터는 기존 시스템, 경쟁사의 시스템 혹은 어떤 종류의 프로토타입 등에서 수집. 이는 전형적인 사용자 자료. 합성 데이터는 어떤 통계적 조건하에서 인공적으로 생성된 데이터.
- GUI 시스템 구동 - GUI 시스템 테스트를 위해서는 특화된 테스트 도구가 필요. 이벤트 갈무리/재생 모델에 기반한 단순한 도구, 혹은 GUI 조작을 위해 특정 스크립트를 필요로 할 수도 있다. 애플리케이션 로직을 검증한 후에는 사용자 인터페이스가 자리한 상태에서 드러나는 버그를 찾기가 쉽다.
- 테스트를 테스트 - 완벽한 소프트웨어 작성이 불가능하기에, 완벽한 테스트 소프트웨어도 작성할 수 없다. 따라서 테스트를 테스트할 필요가 있다. 파괴자를 써서 테스트를 테스트하자. 고의로, 버그를 심고 테스트가 잡아내는지 검증하자. 테스트를 작성할 땐 알람이 제때 울리는지 확인하자.
- 철저히 테스트 - 커버리지 분석 도구는 테스트 중에 코드를 지켜보고, 코드의 어느 라인이 실행되지 않았는지를 알려준다. 하지만 코드의 모든 라인이 실행되는가가 아니라 프로그램이 갖는 상태의 개수에 주목해야 한다. 코드 커버리지보다 상태 커버리지를 테스트하자.

모든 코드는 나오자마자 테스트해야 한다. 테스트는 대부분 자동화되어야 한다. 현존하는 테스트의 그물을 빠져 나가는 버그가 있으면, 다음번에는 그걸 잡아낼 수 있도록 새 테스트를 추가해야 한다. 버그는 한 번만 잡자. 테스터가 버그를 찾아내면, 그 때가 테스터가 그 버그를 찾는 마지막 순간이 되어야 한다. 해당 버그를 확인할 수 있게 자동화 테스트들을 수정해야 한다.



## 44. 결국은 모두 글쓰기

문서화는 전체 개발 프로세스의 필요불가결한 부분이다. 가능하다면 코드 속에 문서를 두자. 프로젝트에서 생산되는 문서에는 기본적으로 내부, 외부 두 종류가 있다. 내부 문서에는 소스코드, 주석, 설계와 테스트 문서 등이 있고, 외부 문서에는 사용자 매뉴얼과 같은 것이 있다.

코드에는 주석이 있어야 하지만, 너무 많은 것은 너무 적은 것만큼이나 좋지 않다. 일반적으로 주석은 왜 이렇게 되어 있는지, 그 목적을 논해야 한다. JavaDoc 도구가 제안하는 주석의 수준이 적절하다. 적절한 주석이 제자리에 있으면, JavaDoc과 같은 도구가 API 수준의 문서를 자동으로 추출, 포맷까지 해줄 수 있다. 파일 내의 코드가 익스포트하는 함수들의 목록, 리비전 기록, 이 파일이 사용하는 파일 목록, 파일이름 등은 주석에 남기지 않도록 주의하자.

문서가 마크업 명령어로된 일반 텍스트로 저장되어 있다면 펄과 같은 도구를 사용해서 스키마를 추출하고, 그걸 자동으로 다시 포맷할 수 있다. 명세와 스키마, 모두 일치한다는 보장을 받게 되면, 모든 변경에 대해 해야 할 일의 양을 최소화하고, 그 변경의 뷰 역시 자동으로 업데이트 할 수 있다. JavaDoc이나 DOC++ 같은 도구를 이와 유사한 방식으로 사용해서 소스코드에서 API 수준의 문서를 만들어 낼 수 있다. 소스코드가 모델이다. 규모가 큰 문서화 프로젝트에서라면 좀 더 현대적인 문서 마크업 체계를 사용하자.

문서와 코드는 밑에 깔려 있는 동일 모델에 대한 서로 다른 뷰이지만, 다른 것이라곤 오직 뷰 뿐이다. 코드를 다룰 때와 똑같은 관심을 문서화에도 주어야 한다.



## 45. 위대한 유산

프로젝트의 성공은 사용자들의 기대를 얼마나 잘 충족하는가에 따라 측정된다. 그들의 기대에 못 미치든, 기대를 너무 지나쳐 버리든 프로젝트는 이론적인 면의 결과물이 얼마나 훌륭하건 간에 상관없이 실패로 간주된다. 사용자의 기대를 부드럽게 넘어서도록 하자. 사용자들의 필요에 대해 이해하고 소통하자. 사용자가 시스템에서 무엇을 얻기를 기대해야 할지에 대해 적극적으로 제어하는 것을 '기대 관리'라고 부른다. 우리는 사용자들과 협동해서, 개발 과정과 최종 전달문에 대한 공통된 이해에 도달해야한다. 약간의 노력을 들여 시스템에 사용자 편의를 위한 기능을 추가한다면, 사용자와의 관계가 좋아질 것이다. 단, 이런 새 기능을 추가하느라 시스템을 망가뜨려서는 안 된다.



## 46. 오만과 편견

실용주의 프로그래머는 책임을 회피하지 않는다. 그 대신 도전을 수용하고 자신의 전문적 지식이 널리 알려지는 것을 기뻐한다. 만약 설계 혹은 코드에 대해 책임을 맡는다면, 자신의 작품에 서명하자. 이 팁의 효과를 보기 위해선, 다른 사람들의 코드를 존중하자. 개발자간의 황금률과 상호 존중이라는 기반을 지키는 것이 핵심이다. 익명성은 적당주의, 실수, 태만, 그리고 나쁜 코드의 번식지가 될 수 있다. 코드의 주인은 꼭 개인일 필요는 없다. 서명이 품질의 보증수표로 인식되게 만들자.
