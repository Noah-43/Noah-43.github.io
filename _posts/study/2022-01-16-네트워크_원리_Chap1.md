---
title: 네트워크_원리_Chap1
excerpt: 성공과 실패를 결정하는 1%의 네트워크 원리 책 1장 정리
categories: study
---

# Chapter 1

## HTTP 리퀘스트 메시지를 작성한다

### URL 입력부터 시작한다

URL(Uniform Resource Locator)

- http: ftp: file: mailto: 로 시작하는 것 등 여러가지가 있다. (해당 부분은 액세스 방법이라고 생각하자)
- 웹 서버나 FTP 서버에 액세스하는 경우에는 서버의 도메인명이나 파일의 경로명 등을 URL에 포함시키며, 메일의 경우 보내는 상대의 메일 주소를 URL에 포함시킨다.
- 필요에 따라 사용자명, 패스워드, 서버측 포트 번호 등을 쓸 수도 있다.

### 브라우저는 먼저 URL을 해독한다
웹 서버에 액세스하는 경우 다음과 같이 동작한다.  
ex) http://www.lab.cyber.co.kr/dir1/file1.html
- http: - 데이터 출처에 액세스하는 방법
- // - 나중에 이어지는 문자열이 서버의 이름임을 나타냄
- www.lab.cyber.co.kr - 웹 서버명
- /dir1/file1.html - '/dir1/' 디렉토리 아래에 있는 'file1.html' 파일에 액세스

### 파일명을 생략한 경우
대부분의 서버가 'index.html' 'default.htm'이라는 파일명을 설정해 둔다. 파일명을 생략했을 때는 위와 같은 파일에 액세스한다.  
ex) http://www.lab.cyber.co.kr/dir/ - '/dir/index.html' 또는 '/dir/default.htm'  
ex) http://www.lab.cyber.co.kr/ - '/index.html' 또는 '/default.htm'  
ex) http://www.lab.cyber.co.kr - 위 경우와 동일  
ex) http://www.lab.cyber.co.kr/whatisthis - 웹 서버에 'whatisthis'라는 파일이 있으면 파일명으로, 디렉토리가 있으면 디렉토리명으로 간주

### HTTP의 기본 개념
HTTP 프로토콜은 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것.  
리퀘스트 메시지에는 무엇을/어떻게 하겠다는 내용을 담는다.
- URI(Uniform Resource identifier): 액세스 대상, 보통 페이지 데이터를 저장한 파일의 이름이나 CGI 프로그램의 파일명을 쓴다.
- 메소드: 웹 서버에 어떤 동작을 하고 싶은지 전달한다.
- 헤더 파일: 보충 정보를 담는 부분

응답 메시지의 맨 앞부분에는 실행 결과의 정상 종료 또는 이상 상태를 나타내는 **스테이터스 코드**가 있다. 그 후 헤더 파일과 페이지의 데이터가 이어지고, 이 응답 메시지를 클라이언트로 반송하면 브라우저가 메시지 안의 데이터를 추출하여 화면에 표시한다.

### HTTP 리퀘스트 메시지를 만든다
- **리퀘스트 라인**: 메소드, URI, HTTP 버전 정보
- **메시지 헤더**: 한 행에 한 개의 헤더 필드를 씀, 부가적인 정보를 나타냄
- **메시지 본문**: 메시지의 실제 내용. GET인 경우 빈 데이터지만, POST의 경우 폼 데이터 등을 메시지 본문에 씀

### 리퀘스트 메시지를 보내면 응답이 되돌아온다
- **스테이터스 라인**: 스테이터스 코드(프로그램 등에 실행 결과를 알려줌)와 응답 문구(사람에게 실행 결과를 알려줌)
- **메시지 헤더**
- **메시지 본문**: 서버에서 클라이언트에 송신하는 데이터, 파일에서 읽은 데이터아 CGI 애플리케이션이 출력한 데이터. 바이너리 데이터로 취급

> 리퀘스트 메시지에 쓰는 URI는 하나뿐으로, 복수의 파일을 읽을 때는 웹 서버에 별도의 리퀘스트 메시지를 보낸다.

## 웹 서버의 IP 주소를 DNS 서버에 조회한다
### IP 주소의 기본
- 네트워크 번호와 호스트 번호를 합쳐서 IP 주소라고 한다.
- 실제 IP 주소는 32비트의 디지털 데이터로, 8비트씩 점으로 구분하여 10진수로 표기한다.
- 네트워크 번호와 호스트 번호의 구분은 넷마스크 정보를 사용한다.

> IP 주소의 호스트 번호
> - 모두 0: 서브넷 자체
> - 모두 1: 브로드 캐스트, 서브넷에 있는 기기 전체에 패킷 전송

### 도메인명과 IP 주소를 구분하여 사용하는 이유
TCP/IP의 네트워크는 이 IP 주소로 통신 상대를 지정해 메시지를 전달한다.  
IP 주소를 기억하는 것은 어렵기에 URL 안에는 IP 주소가 아니라 서버의 이름을 쓰는 것이 좋다.  
하지만 도메인명을 사용하면 데이터의 크기가 커 라우터에게 부하가 걸리게 되고 네트워크의 속도가 느려지는 문제가 발생한다.  
이를 해결해 주는 것이 DNS다. 사람은 이름을, 라우터는 IP 주소를 사용하도록 해 준다.
> DNS(Domain Name System): 서버명과 IP 주소를 대응시키기 위해 사용. 메일 주소와 메일 서버를 대응시키는 것 등 다양한 정보를 이름에 대응해서 등록할 수 있다.

### Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다
IP 주소는 DNS 서버에서 조회하면 된다. DNS 서버에 조회 메시지를 보내고, 거기에서 반송되는 응답 메시지를 받는 것이다.
- 네임 리졸루션(name resolution, 이름 확인): DNS의 원리를 사용하여 IP 주소를 조사하는 것
- DNS 리졸버(리졸버, resolver): DNS 클라이언트, 리졸루션을 실행하는 것, Socket 라이브러리에 들어있는 부품화한 프로그램
> Socket 라이브러리: OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 부품을 모아놓은 것

### 리졸버를 이용하여 DNS 서버를 조회한다
도메인명에서 IP 주소를 조사할 때 브라우저는 Socket 라이브러리의 리졸버를 이용한다.  
C 언어로 작성했다면, 다음과 같이 리졸버의 프로그램명과 웹 서버의 이름을 써서 리졸버를 호출해 IP 주소를 얻을 수 있다.
```
<메모리 영역> = gethostbyname("www.lab.cyber.co.kr");
```

### 리졸버 내부의 작동
1. 네트워크 애플리케이션이 리졸버를 호출
2. 제어가 리졸버의 내부로 넘어감
3. 리졸버에서 DNS 서버에 문의하기 위한 메시지(브라우저가 웹 서버에 보내는 HTTP 리퀘스트 메시지와 유사)를 만들어
4. DNS 서버에 메시지를 보냄(리졸버가 스스로 실행하는 것x. 리졸버도 네트워크 송・수신 기능이 없다. OS 내부에 포함된 프로토콜 스택을 호출하여 실행)
5. LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신
6. 조회 메시지가 DNS 서버에 도착하고 DNS 서버는 조회 내용을 조사하여 답을 찾아 클라이언트에 반송
7. 메시지가 네트워크(LAN 어댑터)를 통해 클라이언트측에 도착
8. 프로토콜 스택을 경유하여 리졸버에게 메시지 전달
9. 리졸버가 내용을 해독한 후 IP 주소를 추출하여 애플리케이션에 IP 주소를 건네줌. 제어가 다시 애플리케이션에게 돌아감

DNS 서버의 IP 주소는 TCP/IP 설정 항목의 하나하나로 컴퓨터에 미리 설정되어있다.

> 프로토콜 스택: OS 내부에 내장된 네트워크 제어용 소프트웨어. '프로토콜 드라이버', 'TCP/IP 소프트웨어' 등으로도 부른다.

## 전 세계의 DNS 서버가 연대한다
### DNS 서버의 기본 동작
DNS 서버의 기본 동작은 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답.

조회 메시지
- 이름: 서버나 메일 배송 목적지(메일 주소 중 @ 뒷부분의 이름)
- 클래스: 네트워크 식별자. 현재는 인터넷 이외의 네트워크 소멸(항상 인터넷을 나타내는 'IN'이라는 값 사용)
- 타입: 이름에 어떤 타입의 정보가 지원되는지를 나타냄. ex) A: IP 주소, MX: 메일 배송 목적지. 타입에 따라 클라이언트 회답 정보 내용이 달라짐.

DNS 서버는 이 세 가지 정보에 대응하여 클라이언트에 회답하는 항목을 설정 파일 등에 입력해 두고, 해당하는 것을 찾아 클라이언트에게 회답한다. 데이터 1건의 정보에 해당하는 것을 **리소스 레코드**라고 한다.

### 도메인의 계층
인터넷에는 막대한 수의 서버가 있기 때문에 전부 1대의 DNS 서버에 등록하는 것은 불가능하다. 그래서 정보를 분산시켜 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지를 찾아내는 구조를 갖는다.  
우선 DNS 서버에 등록한 정보에는 모든 **도메인명**이라는 계층적 구조를 가진 이름이 붙여져 있다.  
도메인을 만든 후 아래에 하위 도메인을 할당할 수 있다.  
ex) www.cyber.co.kr
- kr: 대한민국에 할당된 도메인. 최상위 도메인
- co: 국내의 도메인을 분류하기 위해 설치된 도메인, 회사를 나타냄
- cyber: 회사에 할당된 도메인
- www: 서버의 이름

### 담당 DNS 서버를 찾아 IP 주소를 가져온다
- DNS 서버는 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록하는 식으로 차례대로 등록한다. 이렇게 하면서 상위의 DNS 서버에 가면 하위의 DNS 서버의 IP 주소를 알 수 있고, 거기에서 조회 메시지를 보낼 수 있다.
- com이나 kr라는 도메인(최상위 도메인)의 DNS 서버에 하위의 DNS 서버를 등록한 것에서 끝나는 것 같지만, 사실 인터넷의 도메인은 **루트 도메인**이 존재한다. 루트 도메인에는 도메인명이 없으므로 보통 도메인을 쓸 때 그것을 생략한다.  
  www.lab.glasscom.com 처럼 끝에 마침표를 찍어서 루트 도메인을 명시해 DNS 서버에 com이나 co의 DNS를 등록한다.
- 등록 작업은 한 가지가 더 있는데, 루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서버에 전부 등록하는 것이다.
  클라이언트 PC에서 가장 가까운 DNS 서버로 요청을 보내면 루트 도메인의 DNS 서버부터 서브 DNS 서버로 요청을 보내며 IP 주소를 찾을 수 있다.

### DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다
현실에서는 상위와 하위의 도메인을 같은 DNS 서버에 등록하는 경우도 있고, 한 번 조사한이름을 캐시에 기록하는 경우도 있다.  
조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답해, 편하고 빠르게 회답할 수 있다.  
단, 등록 정보가 변경되는 경우도 있어, 캐시에 저장된 정보가 올바르다고 단언할 수 없고, DNS 서버에 등록하는 정보에는 유효 기한을 설정한다.  
또한 조회에 회답할 때 정보가 캐시에 저장된 것인지, 등록처 DNS 서버에서 회답한 것인지도 알려준다.

## 프로토콜 스택에 메시지 송신을 의뢰한다
### 데이터 송・수신 동작의 개요
IP 주소를 조사했으면, 액세스 대상 웹 서버에 메시지를 송신하도록 OS의 내부에 있는 **프로토콜 스택**에 의뢰한다.  
OS 내부의 프로토콜 스택에 메시지 송신 동작을 의뢰할 때는 Socker 라이브러리 프로그램 부품을 결정된 순번대로 호출한다.

데이터를 송・수신하는 컴퓨터 사이에 데이터의 통로 같은 것이 있고, 이것을 통해 데이터가 흐르면서 양방향 통신이 가능하다고 이해하자.  
데이터 송・수신 단계에 따라 Socket 라이브러리 안의 프로그램 부품을 호출하여 데이터의 송・수신 동작을 실행한다.
1. 소켓을 만든다(소켓 작성 단계)
2. 서버측의 소켓에 파이프를 연결한다(접속 단계)
3. 데이터를 송・수신한다(송・수신 단계)
4. 파이프를 분리하고 소켓을 말소한다(연결 끊기 단계)
   앞의 네 가지 동작을 실행하는 것은 OS 내부의 프로토콜 스택이지 브라우저 등의 애플리케이션 자체가 아니다. Socket 라이브러는 의뢰 받은 내용을 그대로 프로토콜 스택에 전달하는 중개역이라고 이해하자.

### 소켓의 작성 단계
클라이언트측의 소켓을 만들 때는 소켓 라이브러리의 socket이라는 프로그램 부품만 호출하면 된다.
```
<디스크립터> = socket(<IPv4 사용>, <스트림형>, ・・・・・・);
```
소켓이 생기면 **디스크립터**라는 것이 돌아오는데, 애플리케이션은 이 번호표 같은 것으로 소켓을 식별한다.
> socket을 호출한 후의 동작은 리졸버를 호출했을 때와 같이 socket 내부에 제어가 넘어가서 소켓을 만드는 동작 실행 후, 애플리케이션에 제어가 돌아오는 것으로 생각하면 된다.

### 파이프를 연결하는 접속 단계
애플리케이션은 Socket 라이브러리의 connect라는 프로그램 부품을 호출하여 만든 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 위뢰한다.
```
connect(<디스크립터>, <서버의 IP 주소와 포트 번호>, ・・・・・・);
```
이 때 호출할 때 지정하는 정보는 디스크립터, 서버의 IP 주소, 포트 번호이다.
- 디스크립터: 소켓을 만들 때 돌아온 디스크립터. 지정한 디스크립터를 connect가 프로토콜 스택에 통지하고 프로토콜 스택이 통지 받은 디스크립터를 보고 어느 소켓을 서버측의 소켓에 접속할지 판단하여 접속 동작을 실행한다.  
  (애플리케이션이 소켓을 식별하는 것)
- IP 주소와 포트 번호: DNS 서버에 조회하여 조사한 액세스 대상 서버의 IP 주소와 어떤 소켓에 접속할지를 지정하는 포트 번호. 서버측의 포트 번호는 애플리케이션의 종류에 따라 미리 결정된 값을 사용한다. ex) 웹은 80번, 메일은 25번  
  (클라이언트와 서버 간에 상대의 소켓을 식별하는 것)

서버에서는 클라이언트측의 소켓 번호를 어떻게 알까?
- 클라이언트측 소켓의 포트 번호는 소켓을 만들 때 프로토콜 스택이 적당한 값을 골라서 할당하고, 이 값을 프로토콜 스택이 접속 동작을 실행할 때 서버측에 통지한다.


### 메시지를 주고받는 송・수신 단계
소켓이 상대측과 연결된 후에는 Socket 라이브러리의 write라는 프로그램 부품을 사용해 통해 프로토콜 스택에 송신 동작을 의뢰한다.

```
write(<디스크립터>, <송신 데이터>, <송신 데이터의 길이>);
```
먼저 송신 데이터를 메모리에 준비하는데, 이는 사용자가 입력한 URL을 바탕으로 만든 HTTP 리퀘스트 메시지다.  
write를 호출하면 프로토콜 스택이 송신 데이터를 서버에 송신하는데, 소켓에 연결된 상대가 기록되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명되어 그곳을 향해 데이터를 송신한다.  
송신 데이터는 네트워크를 통해 전부 그대로 액세스 대상의 서버에 도착하고, 서버는 수신 동작을 실행하여 받은 데이터의 내용을 조사해 처리하고 응답 메시지를 반송한다.  
메시지가 돌아오면 Socket 라이브러리의 read라는 프로그램 부품을 통해 프로토콜 스택에 수신 동작을 의뢰한다.

```
<수신 데이터 길이> = read(<디스크립터>, <수신 버퍼>, ・・・・・・);
```
수신한 응답 메시지를 저장하기 위한 메모리 영역을 **수신 버퍼**라 부른다. 수신 버퍼는 애플리케이션 프로그램의 내부에 마련된 메모리 영역이므로 수신 버퍼에 메시지를 저장한 시점에서 메시지를 애플리케이션에 건네준다.

### 연결 끊기 단계에서 송・수신이 종료된다
브라우저가 데이터 수신을 완료하면 송・수신 동작은 끝이나고, Socket 라이브러리의 close라는 프로그램 부품을 호출하여 연결 끊기 단계로 들어가도록 의뢰한다. 그러면 소켓 사이 연결이 끊어지고 소켓도 말소된다.
```
close(<디스크립터>);
```
웹에서 사용하는 HTTP 프로토콜에서는 응답 메시지의 송신을 완료했을 때 웹 서버측에서 먼저 close를 호출하여 연결을 끊고, 이것이 클라이언트측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어간다.  
그리고 브라우저가 read로 수신 동작을 의뢰했을 때 read는 수신한 데이터를 건네주는 대신 송・수신 동작이 완료되어 연결이 끊겼다는 사실을 브라우저에 통지하고, 브라우저에서도 close를 호출하여 연결 끊기 단계에 들어간다.

HTTP 프로토콜은 1개의 데이터를 읽을 때마다 접속, 리퀘스트 메시지 송신, 응답 메시지 수신, 연결 끊기를 반복하는데, 같은 서버에서 복수의 데이터를 읽을 때 이는 비효율적이다. 한 번 접속한 후 연결을 끊지 않고 복수의 리퀘스트와 응답 주고받기를 실행하는 방법도 마련되었다. HTTP의 버전 1.1에서 가능한데, 리퀘스트해야 할 데이터가 없어진 상태에서 브라우저에서 연결 끊기 동작에 들어가도록 한다.

---
메시지를 실제로 송・수신하는 것은 프로토콜 스택, LAN 드라이버, LAN 어댑터의 세 가지이다. 이들 세 가지가 연동하여 처음부터 네트워크에 데이터가 흘러간다.
