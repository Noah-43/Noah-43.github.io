---
title: 실용주의_프로그래머_Chap2
excerpt: 실용주의 프로그래머 책 2장 정리
categories: study
---

# 2장. 실용주의 접근법

## 7. 중복의 해악

소프트웨어를 신뢰성 높게 개발하고, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 길은 우리가 DRY(Don't Repeat Yourself) 원칙이라고 부르는 것을 따르는 것 뿐이다. 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현양식을 가져야 한다. 대부분의 중복은 다음 범주 중 하나이다.

- **강요된 중복.** - 개발자들은 다른 선택이 없다고 느낀다. 환경이 중복을 요구하는 것처럼 보인다.
- **부주의한 중복.** - 개발자들은 자신들이 정보를 중복하고 있다는 것을 깨닫지 못한다.
- **참을성 없는 중복.** - 중복이 쉬워 보이기 때문에 개발자들이 게을러져서 중복을 하게 된다.
- **개발자간의 중복.** - 한 팀에 있는(혹은 다른 팀에 있는) 여러 사람들이 동일한 정보를 중복한다.

뭔가를 직접 만드는 것보다 기존의 것을 찾아내고, 재사용하기 쉬운 환경을 만들자. 재사용에 실패한다면 지식 중복의 위험을 각오해야 한다.



## 8. 직교성

설계, 빌드, 테스트 그리고 확장하기에 쉬운 시스템을 만드는 데에 있어 직교성(Orthogonality)은 매우 중요한 개념이다. 컴퓨팅에서의 직교성은 일종의 독립성(independence)이나, 결합도 줄이기(decoupling)를 의미한다. 컴포넌트 단위로 잘 나눠서 관련 없는 것들 간에 서로 영향이 없도록 하자. 직교적인 시스템을 작성하면 **생산성 향상**과 **리스크 감소** 두 가지 장점이 있다. 직교성을 다음의 것들에 적용할 수 있다.

- **프로젝트 팀.** 책임이 잘 정의되어 있고 중복이 최소화된 그룹은 효율적으로 프로젝트를 진행할 수 있다.
- **설계.** 시스템은 협력하는 모듈들의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. 이런 컴포넌트들이 레이어로 조직되기도 하는데, 각 레이어는 하나의 추상화 층을 이루게 된다. 레이어를 사용하면 높은 유연성을 얻음과 동시에 모듈 간에 종속성이 늘어나는 위험을 감소시킬 수 있다.
- **툴킷과 라이브러리.** 클래스를 로컬 서버와 리모트 클라이언트 머신에 분산시키는 기술로는 RMI와 CORBA가 있다. RMI를 사용하여 클래스를 원격에서도 접속할 수 있도록 했다면, 직교적이지 않게 된다. 반면 CORBA를 사용하면 이러한 제약 사항이 없다. 툴킷이나 라이브러리 도입 시에는 코드에 원치 않은 변화를 강요하고 있지는 않은지 검토해 보자. 객체 영속 방식이 투명하다면 이것은 직교적이다. 직교성의 좋은 예로는 EJB 시스템과 AOP가 있다.
- **코딩.** 코드의 직교성을 유지하기 위해서는 코드의 결합도를 줄이고, 전역 데이터와 유사한 함수의 사용을 피하자. 리팩터링을 통해 코드의 구조와 직교성을 향상시키도록 하자.
- **테스트.** 모듈 수준의 테스트가 통합 테스트보다 테스트케이스를 만들고 수행하기 훨씬 쉽다. 따라고, 직교적으로 설계, 구현한 시스템은 테스트하기 더 쉽다. 단위 테스트는 직교성을 테스트해 볼 수 있고, 버그 수정을 통해 시스템의 직교성을 총체적으로 점검해 볼 수 있다.
- **문서화.** 문서에서는 내용과 표현을 두 축으로 잡고 직교성을 적용할 수 있다. 직교적인 문서는 내용 변화 없이 표현을 극적으로 바꿀 수 있다.

DRY 원리를 적용해 시스템 내부의 중복을 최소화시키고, 직교성으로 시스템 컴포넌트 간의 상호의존도를 줄이면 개발중인 시스템은 더 유연하고, 이해하기 쉽고, 디버그, 테스트, 유지가 쉬워질 것이다.



## 9. 가역성

엔지니어는 문제에 대한 단순한 하나의 해결안을 좋아하지만, 무언가를 구현하는 방법에는 여러 가지 길이 있다. 우리가 프로젝트 초기에 항상 최선의 결정을 내리는 것이 아니기에, 유연하고, 적응 가능한 소프트웨어를 만드는 것이 중요하다. 최종 결정이란 없다. 발생할지도 모를 우연한 사건들에 대해 준비하지 않으면 실수가 나오기 마련이다. 코드 뿐만 아니라 아키텍쳐, 배포, 벤더 통합 영역의 유연성도 고민해야 한다. 누구도 미래에 대해서 알 수 없다. 프로젝트를 잘 추상화하여 유지보수성, 유연성을 높이도록 하자.



## 10. 예광탄

예광탄은 실제 탄환과 동일한 환경 조건에서 날아가는데, 맞은 것과 총 사이에 빛의 궤적을 남겨 실제 탄환으로 목표를 조준하기 쉽게 도와준다. 이를 코딩에도 적용하자. 예광탄 코드를 사용해 점진적으로 목표에 도달할 수 있다. 예광탄 코드는 완전한 기능이 들어있지는 않지만 에러검사, 구조화, 문서화, 자기 검사가 포함된 코드로, 버려지는 코드가 아니다. 프로토 타입과 혼동하기 쉬운데, 프로토타입은 나중에 버릴 수 있는 코드를 만들고, 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부를 이룬다는 차이가 있다. 프로토 타입은 예광탄의 발사 전 정찰과 정보 수집 정도로 비유해 볼 수 있다.

예광탄 코드 접근 방법에는 다음과 같은 여러 장점들이 존재 한다.

- 사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다.
- 개발자들은 들어가서 일할 수 있는 구조를 얻는다.
- 통합 작업을 수행할 기반이 생긴다.
- 보여줄 것이 생긴다.
- 진전 상황에 대해 더 정확하게 감을 잡을 수 있다.



## 11. 프로토타입과 포스트잇

프로토타이핑은 실제 제품을 만드는 것에 비해 여러모로 저렴하다. 소프트웨어 프로토타입은 위험 요소를 분석하고 노출시키며 이를 매우 저렴한 비용으로 바로잡을 기회를 준다. 프로토타입을 반드시 코드로 작성할 필요는 없다. 포스트잇은 작업흐름과 애플리케이션 로직과 같은 동적인 것들을 프로토타이핑해 볼 수 있는 훌륭한 도구다. 프로토타입은 제한된 몇 가지 질문에 답할 목적으로 설계되기 때문에, 세부사항을 포기할 수 없는 환경에 처해있다면, 예광탄 스타일의 개발이 더 적절할 것이다.

프로토타입을 통해 조사할 대상에는 다음과 같은 것들이 있다.

- 아키텍처
- 기존 시스템에 추가할 새로운 기능
- 외부 데이터의 구조 혹은 내용
- 써드파티 도구나 컴포넌트
- 성능 문제
- 사용자 인터페이스 설계

프로토타이핑의 진정한 핵심은 이를 통해 배우게 되는 교훈, 학습 경험이다. 프로토타입을 만들때 정확성, 안전성, 안정성, 스타일 등은 무시해도 좋다. 프로토타입에서 기대하는 것은 전체적으로 시스템이 어떻게 동작할지에 대한 감을 잡는 것이다. 세부사항은 무시한다. 아키텍처 프로토타입에서는 다음과 같은 것을 확인해 보자.

- 주요 컴포넌트의 책임이 잘 정의되었고 적절한가?
- 주요 컴포넌트 간의 협력관계가 잘 정의되었는가?
- 결합도는 최소화되었는가?
- 잠재적 중복을 찾아낼 수 있는가?
- 인터페이스 정의와 제약 사항은 수용할만한가?
- 각 모듈이 실행 중에 필요로 하는 데이터에 접근할 수 있는 경로를 갖고 있는가? 모듈은 데이터를 필요로 할 때 데이터에 접근할 수 있는가?

프로토타입 코드는 폐기될 것이고, 불완전하며 완성할 수 없다는 사실을 분명히 기억하자. 프로토타입 코드의 목적이 잘못 해석될 가능성이 크다면, 예광탕 접근 방식을 취해 향후 개발에서 사용할 수 있는 프레임워크를 얻도록 하자.



## 12. 도메인 언어

컴퓨터 언어는 문제에 대해 생각하는 방식과 의사소통에 대해 생각하는 방식에 영향을 미친다. 문제 도메인의 언어가 어떤 프로그래밍적 해경 방안을 제안하기도 한다. 우리는, 사용자들이 원하는 내용을 정확히 표현하는, 그 애플리케이션 도메인에 맞추어진 소형 언어를 만들 수 있다. 소형 언어는 꼭 실행가능할 필요 없이, 단지 사용자의 요구사항을 잡아내는 명세로만 쓰여도 된다. 명세에서 실행 가능한 코드로 나아갈 수도 있다. 이런 과정을 통해 애플리케이션 도메인에 가깝게 프로그래밍 할 수 있다. 애플리케이션의 사용자는 여러 종류가 있다. 각자의 문제 도메인에 맞는 소형 환경과 소형 언어를 만들어 줄 수도 있다.

소형 언어는 파싱하기 쉬운 라인중심 형식의 언어로 만들거나, 기존의 것을 확장하여 만들 수 있다. 구현하는 언어는 애플리케이션이 사용할 어떤 형식의 데이터 구조를 만드는 *데이터 언어*와, 실제로 실행되며, 문장, 제어 구조체 등을 가질 수 있는 *명령형 언어*, 두 가지 방법으로 쓰일 수 있다. 반드시 애플리케이션에 직접 사용되어야만 소형 언어가 유용한 것은 아니다. 컴파일, 읽어들이기, 프로그램 자체가 사용하기 위한 산출물을 만들기 위해 사용할 수 있다. 애플리케이션에 고차원 명령형 언어를 직접 내장해서, 코드가 돌아갈 때 실행되도록 만들 수도 있다. 애플리케이션 도메인이 동적이라면 이런 식으로 유지보수를 간단히 할 수 있다. 현재의 고통을 참고 더 복잡하지만 가독성 좋은 언어를 채택한다면, 지원과 유지보수 비용의 절감으로 보상받게 될 것이다.



## 13. 추정

추정에 대한 지식과 경험을 통해 추정 능력을 계발하고, 어디에 직관적 느낌을 적용해야 할지를 알게 된다면, 무언가의 가능성을 판단할 수 있게 된다. 추정에서 사용하는 단위는 결과의 해석에 차이를 가져온다. 전달하려는 정확도를 고려하여 답변의 단위를 선택하자. 모든 추정치는 문제의 모델에 기반하지만, 항상 좋은 답을 알려주는 기본적인 추정 기술이 있다. 이미 그 일을 해본 사람에게 물어보는 것이다. 다른 사람들의 경험을 통해 성공적인 추정치를 낼 수 있다. 추정할 때는 다음과 같은 것들도 고려해보자.

- 무엇을 묻고 있는지를 이해하자.
- 시스템의 모델을 만들어보자.
- 모델을 컴포넌트로 나누자.
- 각 매개 변수에 값을 주자.
- 답을 계산하자.
- 추정치를 기록, 평가하자.

프로젝트 일정을 추정하기 위해서는 다음과 같은 단계를 반복하는 점증적 개발을 연습하자.

- 요구사항 체크
- 위험 분석
-  설계, 구현, 통합
-  사용자와 함께 검증

초기 기능의 구현과 테스트를 마친 후, 이 경험에 기반해 반복의 횟수와 각 반복에서 무엇을 할지에 대한 초기 추측을 다듬을 수 있다. 코드와 함께 일정도 반복하며 조정하도록 하자.
