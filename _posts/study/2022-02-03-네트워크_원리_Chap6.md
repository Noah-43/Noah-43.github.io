---
title: 네트워크_원리_Chap6
excerpt: 성공과 실패를 결정하는 1%의 네트워크 원리 책 6장 정리
categories: study
---
# Chapter 6

## 서버의 개요
### 클라이언트와 서버의 차이점
- 서버 머신은 용도에 따라 다양한 종류가 있으며, 하드웨어나 OS 부분은 클라이언트와 다를 수 있다.
- 네트워크에 관한 부분, 즉 LAN 어댑터, 프로토콜 스택, Socket 라이브러리 등의 기능은 같고, TCP나 IP의 기능은 하드웨어나 OS가 무엇이든 달라지지 않는다.
- 단, 기능은 같아도 사용하는 방법은 다르다. 접속 시 클라이어트는 접속 동작을 수행하고, 서버는 그것을 기다리기에 애플리케이션이 호출하는 Socket 라이브러리의 부품이 다르다.
- 서버의 애플리케이션은 동시에 다수의 클라이언트 PC와 대화한다.

### 서버 애플리케이션의 구조
- 하나의 프로그램으로 여러 클라이언트의 요청을 처리하지 않고, **멀티태스크** 또는 **멀티스레드**라는 기능을 이용해 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동시켜 1 대 1로 대화한다.
- 접속을 기다리는 부분/클라이언트와 대화하는 부분으로 나눔
  - 접속: 설정 파일 읽기 등의 초기화 동작 후 이 부분이 소켓을 작성, 클라이언트와 접속
  - 대화: 접속이 끝난 소켓을 건네받아 클라이언트와 대화, 대화가 끝나면 연결을 끊고 종료
- 이 방법은 클라이언트가 접속했을 때 새로 프로그램을 기동하는 부분에서 다소 시간이 걸리고, 응답 시간이 추가로 소요된다는 단점이 있다.
- 그래서 미리 클라이언트와 대화하는 몇 개의 부분을 작동시켜 두고 클라이언트가 접속했을 때 클라이언트 상대를 처리하지 않는 비어있는 것을 찾아 접속한 소켓을 건네주어 클라이언트와 대화하는 방법도 있다.

### 서버측의 소켓과 포트 번호
- 데이터 송・수신 동작의 시점에서 보았을 때 접속하는 측이 클라이언트이고, 접속을 기다리는 측이 서버이다.
- 서버의 송・수신 동작 네 단계
  - (1) 소켓을 만든다(소켓 작성 단계)
  - (2-1) 소켓을 접속 대기 상태로 만든다(접속 대기 상태)
  - (2-2) 접속을 접수한다(접속 접수 단계)
  - (3) 데이터를 송・수신한다(송・수신 단계)
  - (4) 파이프를 분리하고 소켓을 말소한다(연결 끊기 단계)
- 구체적인 동작
  - socket을 호출하여 소켓 생성 (1)
  - bind를 호출하여 소켓에 포트 번호를 기록 (2-1)
  - listen을 호출하여 소켓에 접속하기를 기다리는 상태라는 제어 정보 기록 (2-1)
  - 클라이언트에서 접속 동작의 패킷이 도착하는 것을 기다리는 상태가 됨.
  - accept를 호출하여 접속을 접수 (2-2)
    - 서버 애플리케이션 기동 후 즉시 실행됨.
    - accep를 실행한 시점에서 보통 서버측은 패킷의 도착을 기다리는 상태, 애플리케이션은 쉬는 상태
    - 애플리케이션에 접속 패킷이 도착하면 응답 패킷을 반송하여 접속 접수 동작 실행
    - 접속 대기의 소켓을 복사하여 새로운 소켓을 만들고, 접속 상대의 정보를 비롯한 제어 정보를 새 소켓에 기록.
  - 접속한 새로운 소켓을 클라이언트와 주고받는 부분에 건네주고, 대화 실행.
  - 기존의 소켓은 접속 대기 상태인 채로 계속 존재하다 accept를 호출하면 접속 접수 동작을 실행한다.
- 패킷이 어느 소켓에서 대화중인지 판단하는 요소
  - 클라이언트측의 IP 주소
  - 클라이언트측의 포트 번호
  - 서버측의 IP 주소
  - 서버측의 포트 번호
- 소켓을 식별하기 위해 디스크립터를 사용하는 이유
  - 접속 대기의 소켓에는 클라이언트측의 IP 주소와 포트 번호가 기록되어 있지 않음
  - 디스크립터라는 한 개의 정보로 식별하는 쪽이 간단함

## 서버의 수신 동작
### LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다
- LAN 어댑터의 MAC 부분이 패킷을 신호로부터 디지털 데이터로 되돌리고 FCS를 점검한 후 버퍼 메모리에 저장한다.
- CPU는 패킷의 도착을 감시하고 있는 것이 아니라 다른일을 실행중이므로 **인터럽트**를 사용해 LAN 어댑터에서 CPU로 패킷의 도착을 알려, LAN 드라이버가 동작한다.
- LAN 드라이버가 MAC 헤더로부터 프로토콜을 판단하여 프로토콜 스택에 패킷을 건네준다.

### IP 담당 부분의 수신 동작
- 프로토콜 스택의 IP 담당 부분은 IP 헤더의 내용이 규칙에 따라 올바르게 만들어졌는지 점검한다.
- 자신을 대상으로 한 것인지 판단한다.(자신이 대상이 아니라면 경로표에서 중계 대상 조사 후 중계)
- 조각 나누기에 의한 패킷의 분할이 있는지 조사하고 분할되어 있는 경우 일시적으로 메모리에 저장해 두고, 전부 도착한 시점에서 조립하여 원래 패킷으로 복원한다.
- IP 헤더의 프로토콜 번호 항목을 조사하여 TCP 담당 부분 또는 UDP 담당 부분에 패킷을 건네준다.

### TCP 담당 부분이 접속 패킷을 수신했을 때의 동작
- TCP 헤더의 SYN 컨트롤 비트를 확인한다.(1인 경우 접속 동작의 패킷)
- 수신처 포터 번호를 조사하여 이 번호와 같은 번호를 할당한 접속 대기 상태의 소켓이 있는지 확인한다. (없으면 오류 통지 패킷을 클라이언트에 반송)
- 해당하는 접속 대기 소켓을 복사하여 새 소켓을 작성한다.
- 새 소켓에 송신처의 IP 주소나 포트번호, 시퀀스 번호의 초기값, 윈도우 값 등 필요한 정보를 기록하고, 메모리 영역을 확보한다.
- ACK 번호, 보내는 데이터에 관한 시퀀스 번호의 초기값, 수십 버퍼의 빈 용량을 나타내는 윈도우 값등의 항목을 기록한 TCP 헤더를 만들고 IP 담당 부분에 의뢰해 클라이언트에 반송한다.

### TCP 담당 부분이 데이터 패킷을 수신했을 때의 동작
- 도착한 패킷의 송신처 IP 주소, 송신처 포트번호, 수신처 IP 주소, 수신처 포트 번호로부터 해당하는 소켓을 판단한다.
- 지난 데이터로부터 다음 시퀀스 번호의 값을 계산하고, 도착한 패킷의 TCP 헤더에 기록된 시퀀스 번호와 합치되는지 조사해, 합치되면 패킷에서 데이터 조각을 추출하여 수신 버퍼에 저장한다. (이때 데이터를 분할 전의 상태로 되돌림)
- 수신 패킷의 시퀀스 번호와 ACK 번호를 기록한 TCP 헤더를 만들어, IP 담당 부분에 의뢰하여 클라이언트에 반송한다.

### TCP 담당 부분의 연결 끊기 동작
- 연결 끊기 동작은 클라이언트측과 같다.

## 웹 서버 소프트웨어가 리퀘스트 메시지의 의미를 해석하여 요구에 응한다
### 조회의 URI를 실제 파일명으로 변환한다
- 웹 서버의 경우 read에서 받은 데이터의 내용이 HTTP 리퀘스트 메시지가 되는데, 리퀘스트 메시지에는 메소드라는 일종의 명령과 데이터 출처를 나타내는 URI라는 파일의 경로명 같은 것이 있다.
- GET 메소드와 HTML 문서의 파일명을 나타내는 URI를 기록한 리퀘스트의 경우 파일에서 HTML 문서의 데이터를 읽어들이고 이것을 응답 메시지로 반송한다.
- 단순히 URI에 기록되어 있는 경로명의 파일을 읽어오는 것이 아니라, 웹 서버에서 공개하는 가상의 디렉토리 구조의 경로명을 보고 실제 디렉토리와 대응 관계를 조사해 실제 디렉토리 경로명으로 변환 후 파일을 읽어 데이터를 반송한다.
- URI에 쓰여있는 경로명이 파일명을 생략한 형태인 경우 미리 설정한 파일명이 쓰여있는 것으로 간주한다.
- 파일명을 바꿔쓰는 규칙을 서버측에 설정하고 규칙에 따라 파일명을 바꿔쓰고 나서 파일에 액세스하는 웹 서버 애플리케이션도 있다.

### CGI 프로그램을 작동하는 경우
- 데이터를 리퀘스트 메시지의 안에 넣어 브라우저에서 웹 서버로 보낸다.
  - GET: HTTP의 GET 메시지를 사용하여 URI의 뒤에 입력 데이터를 내장해 서버에 보내는 방법
  - POST: HTTP의 리퀘스트 메시지의 메시지 본문에 데이터를 내장해서 서버에 보내는 방법
- 리퀘스트 메시지를 보낸 웹 서버는 먼저 URI의 부분에 쓰인 파일명을 조사하여 프로그램인지 판단한다. (프로그램용 디렉토리명을 설정해두고 디렉토리에 저장한 파일을 전부 프로그램으로 간주하는 방법도 있음)
- 프로그램을 작동시키도록 OS에 의뢰하고, 리퀘스트 메시지에서 데이터를 추출하여 프로그램에게 건네준다.
- 프로그램은 받은 데이터를 처리하여 출력 데이터를 웹 서버에 되돌려준다. (데이터 처리 결과를 클라이언트에 반송하기 위해)
- 출력 데이터는 보통 HTML 태그를 내장한 HTML 문서로 되어 있어, 웹 서버는 이것을 그래도 응답 메시지로 클라이언트에 반송한다. (웹 서버는 내용에 관여하지 않음)

### 웹 서버로 수행하는 액세스 제어
- 사전에 설정해 둔 조건에 따라 액세스 동작 여부를 설정하는 기능을 **액세스 제어**라고 하며, 웹 서버에서 설정하는 조건은 주로 다음의 세 가지이다.
  - 클라이언트의 주소
  - 클라이언트의 도메인명
  - 사용자명과 패스워드
- 클라이언트 IP 주소는 accept로 접속을 접수했을 때 클라이언트의 IP 주소를 점검한다.
- 클라이언트의 도메인명은 DNS 서버를 이용해 클라이언트의 IP 주소에서 도메인명을 조사한다. 도메인명 위조 체크를 위해 도메인명에서 IP 주소를 조사해 송신처 IP 주소와 일치하는지 확인한다. 일치하면 도메인명을 조건과 대조하여 액세스 가능 여부를 판단한다.
  - 이 방법은 DNS 서버의 조회 메시지가 왕래하는 만큼 시간이 걸리며, 그만큼 웹 서버의 응답 시간이 길어진다.
- 사용자명과 패스워드가 설정된 경우, 보통의 리퀘스트 메시지에 해당 데이터가 포함되어 있지 않기 때문에 웹 서버는 정보를 기록하거나 리퀘스트 메시지를 보내도록 응답 메시지를 클라이언트에 통지한다.
- 브라우저는 이 응답 메시지를 받으면 사용자명과 패스워드를 입력하는 화면을 표시해 입력받고, 이것을 리퀘스트 메시지에 기록해 다시 한 번 서버에 액세스 한다. 웹 서버는 통지된 사용자명과 패스워드를 사전에 설정한 것과 대조하여 액세스 가능 여부를 판단하고, 액세스를 허가하는 경우 데이터를 반송한다.

### 응답 메시지를 되돌려 보낸다
- 리퀘스트 메시지에 대해 적절하게 처리하고 처리가 완료되면 응답 메시지를 반송하는데, 이때의 개념은 클라이언트가 리퀘스트 메시지를 웹 서버에 보내는 동작과 같다.
- 응답 메시지를 어디에 보내야 할지를 프로토콜 스택에 알려주어야 하는데, 통신 상대의 클라이언트를 직접 통지하는 것이 아니라 어느 소켓을 사용하여 통신하고 있는지를 나타내는 디스크립터를 통지하여 상대를 지정한다.

## 웹 브라우저가 응답 메시지를 받아 화면에 표시한다
### 응답 데이터의 형식을 보고 본질을 판단한다
- 웹 서버가 보낸 응답 메시지를 수신하고, 화면 표시 동작을 진행한다.
- 화면 표시 동작은 응답 메시지에 저장된 데이터가 어떤 종류인지를 조사하는 것부터 시작하는데, 'Content-Type' 헤더 파일의 값으로 판단하는 것이 원칙이다.
- 데이터의 종류를 조사하면 'Content-Encoding'이라는 헤더 필드의 값을 조사한다. (압축 기술, 부호화 기술에 따라 원래 데이터를 변환하고 나서 메시지에 저장한 경우 어떤 변환을 했는지 조사해 원복)
- Content-Type에 정확한 값이 설정되지 않은 상황에는 요청한 파일의 확장자나 데이터 내용의 포맷 등에서 종합적으로 데이터의 종류를 판단한다. (사양으로 정해진 것이 아닌 부분은 브라우저의 종류나 버전에 따라 동작이 달라짐)

### 브라우저 화면에 웹 페이지를 표시하여 액세스를 완료한다
- 데이터의 종류가 판명되면 그 종류에 따라 화면 표시의 프로그램을 호출하여 데이터를 표시한다.
- HTML의 경우 태그의 의미들을 해석하여 문장을 배치하며 화면에 표시하는데, 실제 화면 표시 동작은 OS가 담당한다.
- 브라우저가 자체에서 표시 기능을 가지고 있는 경우에는 OS에 지시를 내려 화면에 표시하고, 그렇지 않은 경우는 해당 애플리케이션을 호출한다.
  - 플러그인으로 편입된 형태일 수도 있고, 독립된 프로그램일 수도 있다.
  - 어떤 경우든 데이터의 종류에 따라 호출하는 프로그램이 결정되며, 브라우저에 설정되어 있다.
- 이렇게 브라우저는 표시 동작을 마치고 사용자가 다음 행동을 하기를 기다리고, 표시한 페이지 안의 링크를 클릭하거나 URL 입력 상자에 새로운 URL을 입력하면 다시 웹 서버에 대한 액세스 동작이 시작된다.
