---
title: 네트워크_원리_Chap2
excerpt: 성공과 실패를 결정하는 1%의 네트워크 원리 책 2장 정리
categories: study
---
# Chapter 2

## 소켓을 작성한다
### 프로토콜 스택의 내부 구성
> 프로토콜 스택: OS에서 내장된 네트워크 제어용 소프트웨어  
> LAN 어댑터: 네트워크용 하드웨어

##### 애플리케이션
- 네트워크 애플리케이션: 브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램
- Socket 라이브러리: 리졸버 내장

##### OS
- 프로토콜 스택: 상단 TCP UDP / 하단 IP
  - TCP/UDP: 데이터 송・수신 담당. 애플리케이션에서 보낸 의뢰를 받아 송・수신 동작 실행
    > TCP(Transmission Control Protocol) - 브라우저, 메일 등의 일반적인 애플리케이션 데이터 송・수신  
    > UDP(User Datagram Protocol) - DNS 서버에 대한 조회 등에서 짧은 제어용 데이터 송・수신
  - IP(Internet Protocol): 패킷 송・수신 동작 제어. ICMP와 ARP라는 프로토콜을 다루는 부분 포함
    > ICMP(Internet Control Message Protocol) - 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지 통지
    > ARP(Address Resolution Protocol) - IP 주소에 대응하는 이더넷의 MAC 주소 조사

##### 드라이버 소프트웨어
- LAN 드라이버: LAN 어댑터의 하드웨어 제어

##### 하드웨어
- LAN 어댑터: 실제 송・수신 동작. 케이블에 대해 신호를 송・수신

### 소켓의 실체는 통신 제어용 제어 정보
- 소켓: 개념적인 것, 통신 동작을 제어하기 위한 제어 정보(통신 상대의 IP 주소, 포트 번호, 통신 진행 상태) 또는 제어 정보를 기록한 메모리 영역.
> 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 동작한다.

> PID: Process ID. 각 프로그램을 식별하기 위해 OS가 할당하는 번호

### Socket을 호출했을 때의 동작
TCP 프로토콜을 사용하여 데이터를 송・수신 할 때
- 소켓 만들기: 프로토콜 스택은 소켓 한 개 분량의 메모리 영역을 확보하고 초기 상태라는 것을 해당 영역에 기록한다.
- 디스크립터 알려주기: 프로토콜 스택의 내부에 있는 다수의 소켓 중 어느 것을 가리키는지 해당 소켓을 알려준다. 디스크립터를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송・수신 동작을 의뢰할 때 디스크립터를 통지한다.

> 소켓에는 통신하는 곳들의 정보, 상태 등이 모두 기록되어 있어, 프로토콜 스택은 어떤 소켓인지 알면 필요한 정보를 알 수 있다.

## 서버에 접속한다
### 접속의 의미
소켓을 만든 직후에는 아무 정보가 기록되어 있지 않으므로 통신 상대가 누구인지를 모른다. 서버의 IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 접속 동작의 한 가지 역할이다.
- 접속 동작의 첫 번째 동작: 통신 상대와의 사이에 제어 정보를 주고 받아 소켓에 필요한 정보를 기록하고 데이터 송・수신이 가능한 상태로 만드는 것. ex) 클라이언트 측의 IP 주소나 포트 번호를 서버측에 알리는 것

> 버퍼 메모리: 송・수신하는 데이터를 일시적으로 저장하는 메모리 영역
> 접속: 버퍼 메모리의 확보

### 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다
**제어 정보의 종류**
- 헤더에 기입되는 정보(클라이언트와 서버가 서로 연락을 정충하기 위해 주고받는 제어 정보)
- 소켓(프로토콜 스택의 메모리 영역)에 기록되는 정보(상대측에서 볼 수 없는 정보, 프로토콜 스택을 만드는 사람에 따라 달라짐. 단, 중요 정보들은 명령에 의해 볼 수 있는데 이것은 어떤 OS의 프로토콜 스택이든 공통)

(TCP 헤더 포맷 표 공부하기)

### 접속 동작의 실제
Socket 라이브러리의 connect 호출 시
1. TCP 담당 부분에서 접속을 나타내는 제어 정보를 기록한 TCP 헤더를 만든다.
2. TCP 헤더의 송신처와 수신처의 포트 번호로 접속하는 소켓을 지정한다.
3. SYN(컨트롤 비트)을 1로 만들어 IP 담당 부분에 송신하도록 의뢰한다.
4. IP 담당 부분이 패킷 송신 동작을 실행하고 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 이것을 받아 TCP 담당 부분에 전달.
5. TCP 담당 부분이 송신처 수신처의 포트번호 SYN 비트 등을 설정한 TCP 헤더를 만든다.
6. 패킷을 받은 것을 알리기 위해 ACK 컨트롤 비트도 1로 만들어 IP 담당 부분에 반송하도록 의뢰한다.
7. TCP 헤더를 조사하여 접속 동작이 성공했는지 확인하고 소켓에 서버의 IP 주소 포트 번호 등과 함께 접속 완료를 나타내는 제어 정보를 기록한다.(SYN 1은 접속 성공)
8. 패킷이 도착한 것을 서버에 알리이 위해 ACK 비트를 1롤 만들 TCP 헤더를 서버에 반송한다.
9. 서버에 도착하면 접속 동작의 대화 종료

이로써 소켓은 데이터를 송・수신할 수 있는 상태가 되었다. 이때 파이프 같은 것으로 소켓이 연결되었다고 생각할 수 있고, 이를 **커넥션**이라고 한다. 커넥션은 close를 호출하여 연결을 끊기 전까지 존재한다.

## 데이터를 송・수신한다
### 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다
connect에서 애플리케이션에 제어가 되돌아오면 write를 호출하여 송신 데이터를 프로토콜 스택에 건네준다. 여기서 프로토콜 스택은 받은 데이터의 내용에 무엇이 쓰여있는지 알지 못 한다.  
프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 건네주기를 기다린다. 한 번의 송신 의뢰에서 건네주는 데이터의 길이는 애플리케이션의 사정에 따라 다르고, 프로토콜 스택에서 제어할 수 없다. 어느 정도 데이터를 저장한 후 송신 동작을 할 때는 OS 종류나 버전에 따라 다르지만, 다음과 같은 요소로 판단 할 수 있다.
- 한 패킷에 저장할 수 있는 데이터의 크기
  > MTU(Maximum Transmission Unit): 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1,500바이트 (IP헤더+TCP헤더+데이터)  
  > MSS(Maximum Segment Size): 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이
- 타이밍: 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행할 수 있도록 프로토콜 스택 내부에는 타이머가 존재해 일정 시간이 상 결과 시 패킷을 송신한다.

두 판단 요소 중 전자를 중시할 결우 네트워크의 이용효율이 높아지지만 송신 동작이 지연될 수 있고, 후자를 중시하면 지연은 적어지지만 이용효율이 떨어질 수 있으니 양자를 절출해서 송신 동작을 실행해야 한다.  
애플리케이션측에서 송신의 타이밍을 제어할 수도 있다. 브라우저와 같은 대화형 애플리케이션이 서버에 메시지를 보낼 때는 버퍼에 머무는 부분만큼 응답 시간이 지연되므로 '버퍼에 머물지 않고 바로 송신할 것'이라고 지정하는 경우가 많다.

### 데이터가 클 때는 분할하여 보낸다
송신 버퍼에 저장된 데이터가 MSS 길이를 초과하는 경우 다음 데이터를 기다릴 필요가 없다. 송신 버퍼에 들어있는 데이터를 맨 앞 부터 차례대로 MSS의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신한다.  
각 조각을 송신하면 맨 앞부분에 TCP 헤더를 부가하고 소켓에 기록되어 있는 제어 정보를 바탕으로 송신처 포트 번호나 수신처 포트 번호 등 필요한 항목을 기록하고, IP 담당 부분에 건네주어 송신 동작을 실행한다.

### ACK 번호를 사용하여 패킷이 도착했는지 확인한다
데이터를 조각으로 분할해서 송신할 경우, 각 조각이 통신 개시부터 몇 번째 바이트에 해당하는지를 세어두고 TCP 헤더에 기록한다. 이를 **시퀀스 번호**라 한다. 수신측은 패킷이 누락되지 않았음을 알리기 위해 해당 번호에 1을 더해 TCP 헤더의 ACK 번호에 기록하여 송신측에 알려준다.  
실제로 시퀀스 번호는 1부터 시작하지 않고 난수를 바탕으로 산출한 초기값으로 시작하는데, SYN이라는 제어 비트를 1로 설정할 때 시퀀스 번호에도 값을 설정한다.
> 시퀀스 번호와 ACK 번호로 패킷이 수신측에 도착한 것을 확인한다.
TCP의 데이터 송・수신 동작은 양방향이다. 어떻게 동작하는가.
1. 클라이언트에서 서버로 보내는 데이터에 관한 시퀀스 번호의 초기값을 통지한다.
2. 서버에서 ACK 번호와 서버에서 클라이언트에 보내는 데이터에 관한 시퀀스 번호의 초기값을 산출하여 반송한다.
3. 클라이언트에서도 ACK 번호를 산출하여 서버에 반송한다. (데이터 송・수신 준비 완료)
4. 데이터를 양방향으로 보낼 수 있다. 웹의 경우 최초에 클라이언트에서 서버로 메시지를 보낼 것이고, 데이터와 함께 시퀀스 번호를 보낸다.
5. 데이터를 수신한 서버에서 ACK 번호를 반송한다.
6. 서버에서 클라이언트에 데이터를 보내는 경우 반대로 동작한다.

TCP는 상대가 데이터를 받은 것을 확인할 때까지 송신한 패킷을 송신용 버퍼 메모리 영역에 보관해둔다. 그리고 송신한 데이터에 대응하는 ACK 번호가 상대로부터 돌아오지 않으면 패킷을 다시 보낸다. TCP는 오류가 발생해도 데이터가 문제 없이 상대에게 도착하도록 한다.  
도중에 케이블이 분리되거나 서버가 다운되는 등의 이유로 TCP가 아무리 다시 보내도 데이터가 도착하지 않는 경우가 있는데, 이런 경우 TCP 몇 번 다시 보낸 후 회복의 전망이 없는 것으로 보고 데이터 송신 동작을 강제로 종료하고 애플리케이션에 오류를 통지한다.

### 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
- 타임아웃 값: ACK 번호가 돌아오는 것을 기다리는 대기 시간

TCP는 ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단한다.  
데이터 송신 동작을 실행하고 있을 때 항상 ACK 번호가 돌아오는 시간을 계측해 두고, ACK 번호가 돌아오는 시간이 지연되면 이것에 대응하여 대기 시간도 늘린다. 반대로 ACK 번호가 곧바로 돌아오면 대기 시간을 짧게 설정한다.

### 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다
- 윈도우 제어: 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법. ACK 번호가 돌아올 때까지의 시간이 낭비되지 않는다.
- 윈도우 필드: 수신 처리가 끝나고 수신 버퍼에 빈 부분이 생기면 그 분량만큼 수신할 수 있는 데이터 양이 늘어나는데 이를 TCP 헤더의 윈도우 필드에서 송신측에 알린다.
- 윈도우 사이즈: 수신 가능한 데이터 양의 최대값. 보통 수신측의 버퍼 메모리의 크기와 같은 크기.

수신측의 TCP는 패킷을 수신하면 일단 수신용 버퍼 메모리에 데이터를 일시 보관하는데, 버퍼에 쌓인 데이터를 처리하는 것 보다 빠르게 데이터가 쌓이면 데이터가 넘쳐 소실된다. 이를 피하기 위해 먼저 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고, 수신측은 이 양을 초과하지 않도록 송신 동작을 실행한다.

### ACK 번호와 윈도우를 합승한다
- 윈도우 통지 타이밍: 수신측에서 애플리케이션에 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어났을 때.
- ACK 번호의 통지 타이밍: 데이터를 수신한 후 즉시.
  ACK 번호 통지와 윈도우 통지의 패킷이 하나씩 따로따로 송신측에 보내지면 패킷이 많아져 효율성이 저하된다. 통지를 바로 하지 않고 잠시 기다리는 사이에 다음 통지 동작이 일어나면 한 개의 패킷으로 묶어 보낼 수 있다.
- ACK 번호의 송신을 대조할 때 윈도우 통지 발생한 경우 - 한 개의 패킷에 합승시켜 통지
- 복수의 ACK 번호 통지가 연속해서 일어난 경우 - 최후의 것만 통지
- 윈도우 통지가 연속하여 일어난 경우 - 최후의 것만 통지

### HTTP 응답 메시지를 수신한다
HTTP 리퀘스트 메시지를 보낸 후 웹 서버에서 응답 메시지가 돌아오기를 기다리고, 응답 메시지가 돌아오면 그것을 수신한다.  
브라우저는 리퀘스트 메시지를 송신해 달라 의뢰하고, 이것이 끝나면 서버에서 돌아오는 응답 메시지를 받기 위해 read 프로그램을 호출한다. read를 경유하여 프로토콜 스택에 제어가 넘어가고, 프로토콜 스택이 움직이는데, 동작은 서버에서 수신 동작을 수신하던 동작과 같다.

## 서버에서 연결을 끊어 소켓을 말소한다
### 데이터 보내기를 완료했을 때 연결을 끊는다
웹의 경우 브라우저에서 웹 서버에 리퀘스트 메시지를 보내고, 서버가 이것에 응답하여 응답 메시지를 반송 완료하면 데이터 보내기가 완료된 것이고, 서버측이 연결 끊기 단계에 들어간다.  
서버측의 애플리케이션이 먼저 Socket 라이브러리의 close를 호출한다. 그러면 서버측의 프로토콜 스택이 TCP 헤더를 만들고, 여기에 연결 끊기를 나타내는 정보를 설정하는데, 컨트롤 비트의 FIN 비트에 1을 설정하고, IP 담당 부분에 의뢰하여 클라이언트에 송신해 달라고 한다. 이와 동시에 서버측의 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록한다.  
클라이언트 측은 서버에서 FIN에 1을 설정한 TCP 헤더가 도착하면 클라이언트측의 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록한다. 그리고 FIN을 1로 설정한 패킷을 받은 사실을 알리기 위해 ACK 번호를 서버측에 반송하고, 이것이 끝나면 애플리케이션이 데이터를 가지러 올 때까지 기다린다. 잠시 후 애플리케이션이 read를 호출하면 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 클라이언트 측의 애플리케이션(브라우저)에게 알린다. 클라이언트측의 애플리케이션도 close를 호출하여 데이터 송・수신 동작을 끝낸다. 그러면 클라이언트 측의 프로토콜 스택도 FIN 비트에 1을 설정한 TCP 헤더를 만들고 IP 담당 부분에 의뢰하여 서버에 송신한 후 서버에서 ACK 번호가 돌아오면 대화를 끝낸다.

### 소켓을 말소한다
서버와의 대화가 끝나면 소켓은 필요 없지만, 오동작을 막기 위해 잠시 기다린 후 소켓을 말소한다.  
클라이언트에서 연결 끊기 동작이 시작되었을 때 마지막에 서버로 ACK 번호가 돌아오지 않으면 서버는 다시 한 번 FIN을 보낼 수도 있다. 이때 클라이언트의 소켓이 말소되어 있으면 제어 정보가 없어지므로 소켓에 할당되어 있던 포트 번호도 몇 번인지 알수 없게 되는데, 이 시점에 다른 애플리케이션이 소켓을 작성하면 새 소켓에 같은 포트 번호가 할당될 수 있다. 이러면 새 소켓에 FIN이 도착해 연결 끊기 동작에 들어가 버리는 오동작이 발생할 수 있다.  
이때 기다리는 시간은 패킷이 네트워크에 존재할 가능성이 남아있는 다시 보내기 동작이 완전히 끝나는 시간만 기다리면 된다. 명확한 규정은 없지만 일반적으로 보통 몇 분 정도 기다리고 소켓을 말소한다.

## IP와 이더넷의 패킷 송・수신 동작
### 패킷의 기본
패킷은 '헤더'와 '데이터'의 두 부분으로 구성된다.
- 헤더: 수신처를 나타내는 주소 등의 제어 정보.
- 데이터(내용): 패킷으로 운반하는 데이터. 패킷의 내용.

> **서브넷**  
> 라우터: IP 규칙에 따라 헤더 운반. 라우터가 목적지를 확인하여 다음 라우터를 나타냄. IP가 목적지를 확인하여 다음 IP의 중계 장치를 나타냄.
> 허브: 이더넷 규칙에 따라 헤더 운반. 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착. 서브넷 안에 있는 이더넷이 중계 장치까지 패킷 운반.

1. 송신처에서 패킷의 목적지가 되는 액세스 대상 서버의 IP 주소를 헤더의 수신처에 기록
2. 수신처의 방향에 있는 다음 라우터에 도착하도록 이더넷에 의뢰. 다음 라우터에 할당된 이더넷의 주소(MAC 주소)를 조사하고, MAC 헤더에 기록
3. 이더넷의 원리에 따라 움직이는 허브에 도착.
4. 허브에서 패킷의 목적지를 판단하기 위한 표와 이더넷의 헤더의 수신처 정보를 보고 패킷의 목적지를 판단하여 중계. 허브가 복수이면 허브를 순차적으로 경유.
5. 패킷이 다음 라우터에 도착하면 라우터에는 IP용 표가 있어 이것과 IP 헤더의 수신처를 결합하여 다음 중계 라우터를 결정.
6. 해당 라우터의 MAC 주소를 조사하고 MAC 헤더에 기록 후 다음 라우터에 송신.
7. \~~반복\~~
8. 목적지에 패킷이 도착하고 수신처에서 패킷 수신 완료.

### 패킷 송・수신 동작의 개요
TCP 담당 부분이 데이터의 조각에 TCP 헤더를 부가한 것을 IP 담당 부분에 건네며 의뢰하면, IP 담당 부분은 그 앞에 제어 정보를 기록한 헤더를 부가한다. 이 때 IP 헤더와 MAC 헤더를 부가한다.
> MAC 헤더: 이더넷용 헤더, MAC 주소를 쓴다. 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보  
> IP 헤더: IP용 헤더, IP 주소를 쓴다. IP 프로토콜에 규정된 규칙에 따라 IP 주소로 표시된 목적지까지 패킷을 전달할 때 사용하는 제어 정보

만든 패킷을 네트워크용 하드웨어(이더넷, 무선 LAN 등. LAN 어댑터)에 건네준다. 이 때 패킷의 모습은 0이나 1의 비트가 이어진 디지털 데이터. LAN 어댑터에 의해 전기나 빛의 신호 상태로 바뀌어 케이블에 송출되고, 이 신호는 허브나 라우터 등의 중계 장치에 도착해, 중계 장치가 상대가 있는 곳까지 패킷을 전달한다.  
수신 시에는 그 반대로 중계되어 패킷이 운반되어 온다. 케이블에서 신호의 모습을 한 패킷이 들어오면 LAN 어댑터에서 디지털 데이터의 모습으로 되돌리고 해당 디지털 데이터의 패킷을 IP 담당부분이 받아 TCP 헤더와 데이터 조각을 TCP 담당 부분에게 건네준다.

> IP가 패킷을 송・수신하는 동작은 제어 패킷이든, 데이터의 패킷이든 패킷의 역할에 상관 없이 모두 같다.

### 수신처 IP 주소를 기록한 IP 헤더를 만든다
- IP 헤더의 수신처 IP 주소에는 통신 상대의 주소 설정
- 송신처 IP 주소는 송신처가 되는 LAN 어댑터를 판단하여 주소 설정

**경로표**
- 수신처 IP 주소를 Network Destination 항목과 비교하여 어느 행에 해당하는지 찾아냄.
- Interface 항목은 LAN 어댑터 등의 네트워크용 인터페이스를 나타냄. 인터페이스에서 패킷을 송신하면 상대에 패킷을 전해줄 수 있다는 의미.
- Gateway 항목에는 다음 라우터의 IP 주소가 기록되어 있음.
- 첫째 행에는 목적지와 넷마스크가 0.0.0.0으로 등록되어 있는데, 기본 게이트웨이를 의미. 다른 곳에 일치하는 것이 없으면 이 행이 해당하는 것으로 간주.

> 프로토콜 번호: TCP, UDP등 어떤 프로토콜에서 의뢰받은 것인지를 나타내는 필드 값.

### 이더넷용 MAC 헤더를 만든다
이더넷은 TCP/IP와 다른 구조로 패킷의 수신처를 판단. 이더넷의 수신처 판단 구조로 사용하는 것이 MAC 헤더(수신처나 송신처의 MAC 주소 등 기록).

**MAC 헤더**
- 이더 타입: IP 헤더의 프로토콜 번호와 유사. 이더넷은 이더 타입 뒤에 이어지는 것이 패킷의 내용물로 생각하는데, 그 내용물이 무엇인지를 이더 타입으로 나타냄. 이더넷의 내용물은 IP나 ARP 프로토콜의 소켓이며, 각각에 대응하는 값을 헤더에 기록.
- 송신처 MAC 주소: 자체 LAN 어댑터의 MAC 주소 설정. LAN 어댑터의 ROM에 기록된 값을 읽어와 MAC 헤더로 설정.
- 수신처 MAC 주소: 패킷을 건네주는 상대의 MAC 주소 설정. 이 시점에서 누구에게 패킷을 건네주어야 할지 몰라 패킷을 건네줄 상대를 조사해야 함. 경로표의 Gateway 항목에 기록되어 있는 IP 주소의 기기가 패킷을 건네줄 상대가 됨.(다음 내용 참고)

### ARP로 수신처 라우터의 MAC 주소를 조사한다
- ARP(Address Resolution Protocol): 브로드캐스트 구조를 이용하여 MAC 주소를 조사. ARP 캐시라는 메모리 영역을 이용하여 MAC 주소 조사할 때마다 패킷이 불어나는 것을 방지.

### 이더넷의 기본
이더넷은 한 대가 신호를 보내면 전원에게 신호가 도착하고, 수신처 주소 정보를 통해 누구에게 가는 신호인지를 판단할 수 있어 해당 기기는 패킷을 수신하고 그 외의 기기는 패킷을 폐기한다.  
**이더넷**
1. 수신처 MAC 주소에 따라 패킷이 누구에게 갈 것인지를 알고
2. 송신처 MAC 주소에 따라 누가 송신한 것인지 알며
3. 이더 타입에 의해 패킷의 내용물로 무엇이 들어있는지를 안다.

### IP 패킷을 전기나 빛의 신호로 변환하여 송신한다
LAN 어댑터는 디지털 데이터를 전기나 빛의 신호로 변환하여 네트워크의 케이블에 송출하는 역할을 한다. 이는 단독으로 동작하지 않고 LAN 드라이버 소프트웨어를 통해 제어된다.  
LAN 어댑터의 ROM에는 전 세계에서 중복되지 않도록 일원화되어 관리되는 MAC 주소가 제조할 때 기록되어 있고 이 주소를 LAN 드라이버가 읽어와 MAC 회로에 설정한다.

### 패킷에 3개의 제어용 데이터를 추가한다
LAN 드라이버가 IP 담당 부분에서 패킷을 받아 LAN 어댑터의 버퍼 메모리에 복사를 마친 후 패킷을 송신하도록 MAC 회로에 명령을 보내면 MAC 회로의 작업이 시작된다.  
MAC 회로는 송신 패킷을 버퍼 메모리에서 추출하고 맨 앞에는 **프리앰블**과 **스타트 프레임 딜리미터**라는 두개의 데이터를, 맨 끝에는 **프레임 체크 시퀀스**라는 오류 검출용 데이터를 부가한다.

> 프리앰블: 송신하는 패킷을 읽을 때의 타이밍을 맞추는 용도  
> 프레임 딜리미터(SFD): 프레임의 개시 위치를 찾는 용도  
> 프레임 체크 시퀀스(FCS): 패킷 운반 중 데이터가 변한 경우 이것을 검출하기 위한 용도

### 허브를 향해 패킷을 송신한다
드디어 완성된, 케이블에 송출할 패킷 신호를 송신한다.  
LAN 어댑터의 MAC 회로가 공통 형식읜 신호를 만들고 PHY(MAU) 회로가 케이블에 송출하는 형식으로 변환하여 케이블에 송신한다.
- **반이중 모드**(리피터 허브 사용): 신호 송신 중 수신 신호가 흘러오면 서로의 신호가 뒤섞여 분간할 수 없는 충돌이 발생. 충돌이 일어나면 재밍 신호를 흘리고 송신 동작을 멈추고 기다렸다 다시 송신 동작 시도함.
- **전이중 모드**(스위칭 허브 사용): 송신과 수신을 동시에 실행하면서 충돌이 일어나지 않음. 수신 신호선에서 신호가 흘러와도 단순히 신호를 보내기만 함.


### 돌아온 패킷을 받는다
1. 수신 동작은 신호를 받아들이는 것부터 시작
2. 프리앰블과 스타트 프레임 딜리미터를 보고 그 다음 비트부터 디지털 데이터로 변환하여 동작 개시
3. PHY(MAU) 회로에서 신호를 공통 형식으로 변환하여 MAC 회로에 보내고, MAC 회로에서는 디지털 데이터로 변환하여 버퍼 메모리에 저장 및 FCS 검사
4. MAC 헤더의 수신처 MAC 주소를 조사해 자신에게 오는 것인지 판단하여 버퍼 메모리에 저장
5. 패킷을 수신한 사실을 컴퓨터 본체에 통지(인터럽트)
6. LAN 드라이버가 동작하고 LAN 어댑터의 버퍼 메모리에서 수신한 패킷을 추출해, MAC 헤더 타입 필드 값으로 프로토콜 판별

### 서버의 응답 패킷을 IP에서 TCP로 넘긴다
프로토콜이 TCP/IP 통신에 사용하는 프로토콜이었다 가정
1. LAN 드라이버는 TCP/IP 프로토콜 스택에 패킷 전달
2. IP 담당부는 IP 헤더를 조사하여 포맷에 문제가 없는지 확인하고, 수신처 IP 주소를 조사
3. 이때 수신처 IP 주소가 자신의 주소와 다르다면 ICMP라는 메시지를 사용하여 통신 상대에게 오류 통지
4. 프래그먼테이션이 발생한 패킷들이라면 IP 헤더의 플래그/ID 정보/프래그먼트 오프셋 정보를 이용해 리어셈블링하고 TCP 담당 부분에 건네줌
5. TCP 담당 부부은 IP 헤더의 수신처/송신처 IP 주소, 포트 번호 네 가지 항목을 조사하여 해당 소켓을 찾아 적절한 동작을 실행

## UDP 프로토콜을 이용한 송・수신 동작
### 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다
TCP는 데이터를 확실하면서도 효율적으로 전달하기 위해 동작이 복잡하다. 하지만 데이터가 한 개인 패킷에 수용할 수 있을 만큼 길이가 짧다면, 데이터를 전부 다시 보낸다 해도 패킷을 한 개만 보내므로 낭비가 아니다. 이런 경우에는 UDP가 효율적이다.

### 제어용 짧은 데이터
- DNS 서버에 대한 조회 등 제어용으로 실행하는 정보 교환은 한 개의 패킷으로 끝나는 경우가 많아 TCP가 아니라 UDP를 사용
- UDP는 수신 확인/윈도우, 접속/연결 끊기 단계 등이 없다. 송신 데이터를 받아 UDP 헤더를 부가하고 IP에 의뢰하여 송신하고, 수신은 IP/UDP 헤더 정보와 소켓에 기록된 정보를 결합하여 데이터를 건네줄 대상 애플리케이션을 판단해 건네주기만 하면 된다.

### 음성 및 동영상 데이터
음성이나 영상 데이터는 결정된 시간 안에 데이터를 건네주어야 하고, 데이터가 다소 없어도 치명적인 문제가 되지 않는 성질이 있다. 이처럼 다시 보낼 필요가 없거나 다시 보내도 쓸모 없는 경우 UDP로 데이터를 보내는 쪽이 효율적이다.
