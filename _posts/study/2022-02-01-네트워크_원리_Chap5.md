---
title: 네트워크_원리_Chap5
excerpt: 성공과 실패를 결정하는 1%의 네트워크 원리 책 5장 정리
categories: study
---
# Chapter 5

## 웹 서버의 설치 장소
### 사내에 웹 서버를 설치하는 경우
- 사내의 LAN에 서버를 설치하고, 인터넷에서 직접 액세스하는 경우는 IP 주소의 부족과 보안상의 이유로 현재 잘 사용하지 않는다.
- 지금은 방화벽을 두는 방법이 일반화 되었다. 방화벽은 특정 서버에서 동작하는 특정 애플리케이션에 액세스하는 패킷만 통과시키고, 그 외의 패킷을 차단하는 역할을 한다.

### 데이터센터에 웹 서버를 설치하는 경우
- 프로바이더 등이 운영하는 데이터센터라는 시설에 서버를 가지고 들어가서 설치하거나 프로바이더가 소유하는 서버를 빌려쓰는 형태로 운영하는 경우도 있다.
- 이 경우 인터넷의 중심 부분에서 데이터 센터로 패킷이 흘러가고, 데이터센터에 방화벽 등이 설치되었으면 점검을 받고 서버에 도착한다.
- 데이터 센터에 서버를 설치하면 고속 액세스 및 안전성의 이점을 누릴 수 있다.

## 방화벽의 원리와 동작
### 패킷 필터링형이 주류이다
- 방화벽의 기본이 되는 개념은 특정 서버와 해당 서버 안의 특정 애플리케이션에 액세스하는 패킷만 통과시키고, 그 외긔 패킷을 차단하는 것이다.
- 네트워크에는 다양한 종류의 패킷이 흐르고, 이 패킷들을 선별하는 것은 간단한 일이 아니기 때문에 다양한 방법이 고안되었다.
- 성능, 가격, 사용 편의성 등의 이유로 지금은 **패킷 필터링형**이 가장 많이 보급되었다.

### 패킷 필터링의 조건 설정 개념
- 패킷의 헤더에는 통신 동작을 제어하는 제어 정보가 들어있어 이것을 조사하면 여러 가지 사항을 알 수 있다.
- 패킷 필터링의 조건을 설정할 때는 패킷의 흐름에 착안하여, 수신처 IP 주소와 송신처 IP 주소에 따라 시점과 종점을 판단한다. (인터넷에서 보내오는 패킷의 경우 종점이 웹 서버)
- 인터넷측에서 웹 서버로 흘러가는 패킷을 방화벽을 통과하도록 설정할 때는 정확하게 도착했는지를 송신측에 알리는 수신 확인 응답 패킷도 통과하도록 설정해줘야한다.
- 이 처럼 수신처나 송신처의 주소에 따라 패킷이 어디서, 어디로 흘러가는지를 판단해 통과/차단을 결정하는 것이 첫걸음이다.

### 애플리케이션을 한정할 때 포트 번호를 사용한다
- 인터넷과 웹 서버 사이를 흐르는 패킷을 전보 통과시키면 위험하므로 애플리케이션을 한정해 패킷을 차단해야한다.
- TCP 헤더나 UDP 헤더에 기록되어 있는 포트 번호를 조건으로 추가한다. (웹 서버의 경우 포트 번호 80)

### 컨트롤 비트로 접속 방향을 판단한다
- 패킷이 흐르는 방향이 아니라 액세스 방향을 판단하여 정지 시켜야하는 경우에는 TCP 헤더에 있는 컨트롤 비트를 사용할 수 있다. (최초이 패킷만 TCP 컨트롤 비트의 SYN 비트 1, ACK 비트 0)
- 실제로는 통과시키는 것과 차단하는 것을 완전히 선별할 수 없는 경우도 있는데, DNS 서버와 같이 UDP를 사용하여 액세스하는 경우가 대표적인 예이다.
- UDP는 TCP와 달리 접속 단계의 동작이 없어 컨트롤 비트에 의해 액세스 방향을 판별할 수 없다.
- 이 경우 어느 정도 위험을 각오한 상태에서 애플리케이션의 패킷을 전부 통과시키거나, 불편을 감수하고 애플리케이션을 전면적으로 차단하는 방법을 선택해야 한다.

### 사내 LAN에서 공개 서버용 LAN으로 조건을 설정한다
- 인터넷과 공개 서버용 LAN을 왕래하는 패킷의 조건 설정 뿐 아니라 사내 LAN과 인터넷 또는 사내 LAN과 공개 서버용 LAN을 왕래하는 패킷의 조건도 설정이 필요하다.
- 이때 조건이 서로 악영향을 끼치지 않도록 주의하여 신중하게 조건을 설정해야 한다.

### 밖에서 사내의 LAN으로 액세스할 수 없다
- 패킷 필터링형 방화벽은 주소 변환의 기능도 가지고 있어 설정이 필요하다.
- 인터넷과 사내 LAN을 왕래하는 패킷은 주소 변환을 해야하는데, 패킷 필터링과 마찬가지로 패킷의 시점과 종점을 조건으로 지정해 주소 변환이 필요한 경우 변환하도록 설정한다.
- 주소 변환을 이용하면 당연히 인터넷측에서 사내 LAN에 액세스할 수 없어 따로 조건을 설정할 필요가 없다. (공개 서버용 LAN과 사내 LAN 사이에서는 프라이비트 주소를 경로표에 수동 설정해 중계, 인터넷은 프라이비트 주소를 등록하지 않아 패킷 폐기)

### 방화벽을 통과한다
- 방화벽은 여러 조건을 통해 패킷을 통과시킬지와 차단할지를 결정하고, 차단된 대상 패킷은 버리고, 그 기록을 남긴다. (부정 침입 흔적 분석 및 대책 마련 용도)
- 통과시키는 경우 패킷을 중계하는데, 라우터의 동작과 같다.
- 판정 조건이 복잡해지면 라우터의 명령으로 설정이 어렵고, 기록을 남기는 것이 라우터에 부담이 되기 때문에 전용 하드웨어나 소프트웨어를 사용하는 것인데, 복잡한 조건 설정 및 버린 패킷의 기록이 필요하지 않다면 패킷 필터링 기능을 가진 라우터를 방화벽으로 사용할 수도 있다.

### 방화벽으로 막을 수 없는 공격
- 패킷의 내용을 조사하지 않으면 위험한지 판단할 수 없어 방화벽의 구조는 특수한 데이터를 포함한 패킷을 받아 웹서버가 다운되는 상황 등에 대처할 수 없다.
- 두 가지 대처법이 있다.
  - 웹 서버 소프트웨어의 버그를 고쳐 다운되지 않도록 한다.
  - 패킷의 내용을 조사하여 위험한 데이터가 포함되어 있는 경우 패킷을 차단하도록 장치나 소프트웨어를 방화벽과 별도로 준비한다.
- 단, 위 방법은 완벽하지 않고 미지의 위험성에는 대처할 수 없다. 하지만 여러 대의 서버가 있는 경우 새로운 버전으로 바꾸는 것을 미루거나 잊기 쉬워 효과가 있다.

## 복수 서버에 리퀘스트를 분배한 서버의 부하 분산
### 처리 능력이 부족하면 복수 서버로 부하 분산된다
- 서버에 액세스가 증가할 때는 복수의 서버를 사용하여 처리를 분담하여 서버 한 대당 처리량을 줄일는 것이 효과적인데, 이러한 처리 방법을 **분산 처리**라고 하고, 처리 분담 방식은 여러 가지가 있다.
- 가장 간단한 방법은 단순히 여러 대의 웹 서버를 설치하고 한 대가 담당하는 사용자 수를 줄이는 방법으로, 클라이언트 리퀘스트를 웹 서버에 분배하는 것은 DNS 서버에서 분배하는 방법이 가장 간단하다.
- DNS 서버에 같은 이름으로 여러 대의 웹 서버를 등록해 놓으면 DNS 서버는 조회가 있을 때마다 라운드 로빈 방식으로 IP 주소를 회답해준다.
- 이 방법은 복수의 서버에 균등하게 액세스를 분산시킬 수 있으나, 고장난 웹 서버의 IP 주소를 DNS가 확인할 수 없어 해당 IP 주소를 회답해 버리거나, 복수의 페이지에 걸쳐 대화할 경우 웹 서버가 변하면 대화가 도중에 끊기는 문제가 발생한다.

### 부하 분산 장치를 이용해 복수의 웹 서버로 분할된다
- **부하 분산 장치** 또는 **로드 밸런서** 등으로 부르는 기기를 웹 서버 대신 DNS 서버에 등록하면, 클라이언트는 여기에 리퀘스트 메시지를 전송한다.
- 어느 웹 서버에 리퀘스트를 전송해야하는지를 판단하는 근거는 여러 가지가 있디만, 복수 페이지에 걸쳐있지 않은 단순 액세스의 경우 웹 서버의 부하 상태가 판단 근거가 된다.
  - 로드 밸런서는 일반적으로 웹 서버와 정기적으로 정보를 교환하여 CPU/메모리 사용률 등을 수집하거나, 시험 패킷을 웹 서버에 보내 응답 시간을 확인하는 방식으로 부하를 판단한다.
- 대화가 복수 페이지에 걸쳐있을 때는 웹 서버의 부하게 관계 없이 이전의 리퀘스트와 같은 웹 서버에 전송해야 한다.
  - 요청이 복수 페이지에 걸쳐있는지 판단하기 위해 데이터를 보낼 때 그 안에 전후의 관련을 나타내는 정보를 부가하거나 HTTP의 사양을 확장하여 전후 관계를 판단하기 위한 정보를 HTTP 헤더 필드에 부가하는 방법이 있다.
- 부하 분산 장치는 요청이 일련의 동작이라면 이전과 같은 웹 서버에 리퀘스트를 전송하고, 그렇지 않으면 부하가 적은 웹 서버에 전송하도록 동작한다.

## 캐시 서버를 이용한 서버의 부하 분산
### 캐시 서버의 이용
- 역할별 분산 처리 방법 중의 하나로 **캐시 서버**를 사용하는 방법이 있다.
- 캐시 서버는 **프록시**라는 구조를 사용하여 데이터를 캐시에 저장하는데, 프록시는 웹 서버와 클라이언트 사이에서 웹 서버에 대한 액세스 동작을 중개하는 역할을 하는데, 액세스 동작을 중개할 때 웹 서버에서 받은 데이터를 디스크에 저장해 두고 웹 서버를 대신하여 데이터를 클라이언트에 반송하는 기능을 가지고 있다.
- 캐시 서버는 웹 서버 보다 빨리 데이터를 송신하고, 웹 서버의 부하를 줄일 수 있지만, 이용할 수 없는 경우도 있다.

### 캐시 서버는 갱신일로 콘텐츠를 관리한다
- 캐시 서버를 사용할 땐느 부하 분산 장치와 마찬가지로 캐시 서버를 웹 서버 대신 DNS 서버에 등록해, 사용자의 HTTP 리퀘스트 메시지를 받는다.
- 데이터가 캐시에 저장되어 있지 않은 경우의 동작
  1. 리퀘스트 메시지의 내용을 조사해, 데이터가 자신의 캐시에 저장되었는지 조사한다.
  2. 캐시 서버는 리퀘스트 메시지에 캐시 서버를 경유한 것을 나타내는 'Via' 헤더 필드를 추가하여 웹 서버에 리퀘스트를 전송한다.
  3. 웹 서버가 한 대 밖에 없으면 웹 서버의 도메인명이나 IP 주소를 캐시 서버에 설정해 두고 거기에 전송하고, 한 대의 캐시로 여러 대의 서버의 데이터를 캐시에 저장하는 경우에는 대표적으로 리퀘스트 메시지의 URI에 쓰여있는 디렉토리를 보고 판단해 전송 대상을 설정해 전송한다.
  4. 캐시 서버가 클라이언트가 되어 웹 서버에 리퀘스트 메시지를 보내면, 웹 서버는 캐시 서버에 응답 메시지를 보낸다.
  5. 웹 서버에서 반송한 응답 메시지에 캐시 서버를 경유한 것을 나타내는 'Via' 헤더 필드를 부가해, 클라이언트에 대해 웹 서버가 되어 캐시 서버가 응답 메시지를 전송한다. 그리고 응답 메시지를 캐시에 저장하고 저장한 일시를 기록한다.
  - 이렇게 클라이언트와 웹 서버 사이를 중개하는 것이 프록시 구조이다.
- 데이터가 캐시에 저장되어 있는 경우의 동작
  1. 캐시에 저장되어있는지를 조사한다.
  2. 웹 서버측에서 데이터가 변경되었는지 조사하기 위한 'If-Modified-Since'라는 헤더 필드를 추가하여 웹 서버에 전송한다.
  3. 변경됨/변경되지 않음
  - 변경되지 않음
    1. 웹 서버는 'If-Modified-Since' 헤더 필드의 값과 페이지 데이터의 최종 갱신 일시를 비교하여 변경이 없으면 변경이 없는 것을 나타내는 응답 메시지를 반송한다. 이때 웹 서버는 데이터의 최종 갱신 일시를 조사하는 것으로 끝나고, 반송 응답 메시지가 짧아 페이지 데이터 반송보다 부담이 적어진다.
    2. 응답 메시지가 캐시 서버에 도착하면, 캐시에 저장한 데이터가 최신 데이터와 같은 것을 알 고 캐시 서버는 캐시에서 데이터를 추출하여 사용자에게 보낸다.(응답 메시지의 내용은 캐시에 데이터가 없던 경우와 동일)
  - 변경됨 - 캐시에 데이터가 저장되어 있지 않은 경우와 동일
    1. 웹 서버는 최신 데이터를 반송한다.
    2. 'Via' 헤더를 부가하여 사용자에게 전송하고 데이터를 캐시에 저장한다.
- 위 캐시 서버는 프록시 구조를 웹 서버측에 두고 캐시 기능을 이용한 것이다.
### 프록시의 원점은 포워드 프록시이다
- 캐시 서버에서 이용하는 프록시라는 구조는 원래 클라이언트측에 두는 방법에서 시작되었는데, 이는 프록시의 원형으로, **포워드 프록시**라고 한다.
- 포워드 프록시는 캐시 이용과 함께 방화벽을 실현한다는 목적이 있었다.
- 프록시에서 리퀘스트 메시지를 일단 받아서 인터넷을 향해 전송하면 필요한 것을 통과시킬 수 있다는 개념이다.
  - 캐시를 이용하면 이전에 액세스한 페이지의 경우 사내 LAN에서 프록시에 액세스하기만 하면 데이터를 얻을 수 있어 매우 빨라진다.
  - 리퀘스트의 내용을 조사한 후 전송하므로 리퀘스트의 내용에 따라 액세스가 가능한지 판단할 수 있어, 패킷 필터링형 방화벽보다 자세히 조건 설정이 가능하다.
- 포워드 프록시를 사용할 경우 보통 브라우저의 설정 화면에 준비되어 있는 프록시 서버 항목에 포워드 프록시의 IP 주소를 설정한다.
- 포워드 프록시를 설정하면 URL을 그대로 리퀘스트의 URL에 기록하고 해당 URL이 전송 대상이 된다.
- 따라서 전송 대상의 웹 서버를 사전에 설정해 둘 필요는 없고, 모든 웹 서버에 전송할 수 있다. (서버측에 두는 캐시 서브는 설정해 둔 웹 서버에만 전송 가능)

### 포워드 프록시를 개량한 리버스 프록시
- 포워드 프록시를 사용할 경우 브라우저에 대한 설정이 꼭 필요한데, 설정이 번거롭고 잘못 설정할 경우에는 브라우저가 제대로 작동하지 않는 장애의 원인이 되기도 한다.
- 이에 따라 브라우저에 프록시를 설정하지 않아도 사용할 수 있도록, 리퀘스트 메시지의 URI에 쓰여있는 디렉토리명과 전송 대상의 웹 서버를 대응시켜 URI 부분에 http://~~~ 라고 쓰여있지 않은 보통의 리퀘스트 메시지를 전송할 수 있도록 했다.
- 이것이 서버측에 설치하는 캐시 서버에 채택하고 있는 방식으로, **리버스 프록시**라고 부른다.

### 트랜스페어런트 프록시
- IP 헤더에는 수신처 IP 주소가 기록되어 있으므로 이것을 조사하면 액세스 대상 웹 서버가 어디에 있는지 알 수 있는데, 이 방법을 **트랜스페어런트 프록시**라고 부른다.
- 포워드 프록시처럼 브라우저에 설정할 필요도, 전송 대상을 캐시 서버에 설정할 필요도 없고, 어느 웹 서버에서나 전송할 수 있다.
- 트랜스페어런트 프록시를 DNS 서버에 등록할 수 없어(프록시 자체가 액세스 대상이 되어버림), 브라우저에서 웹 서버로 리퀘스트 메시지가 흘러가는 길에 설치해, 메시지가 통과할 때 그것을 가로챈다.
- 리퀘스트 메시지가 흐르는 길이 많으면 전부 트랜스 페어런트 프록시를 설치해야 하므로, 보통 길이 수렴하는 인터넷에 연결하는 액세스 회선 부분에 설치한다.
- 트랜스페어런트 프록시를 사용하면 사용자가 프록시의 존재를 알아차릴 필요가 없어 HTTP 메시지를 전송한다는 구조에 대한 관심이 적어지고 캐시를 이용할 수 있다.

## 콘텐츠 배포 서비스
### 콘텐츠 배포 서비스를 이용한 부하 분산
- 캐시 서버를 서버측에 두는 경우 웹서버의 부하를 경감하는 효과는 있지만, 인터넷에 흐르는 트래픽을 억제하는 효과는 없고, 클라이언트측에 캐시 서버를 두는 경우 웹 서버 운영자가 제어할 수 없다.
- 양쪽의 좋은 점을 취한 방법으로, 프로바이더와 계약하여 웹 서버 운영자가 제어할 수 있는 캐시 서버를 클라이언트측의 프로바이더에 두는 방법이 있다.
- 하지만 인터넷에 공개하는 서버는 어디에서 액세스하는지 알 수 없어, 캐시 서버를 많이 설치해야하고 웹 서버 운영자의 부담이 커진다.
- **콘텐츠 배포 서비스**, 캐시 서버를 설치하고, 이것을 웹 서버 운영자에게 대출하는 서비스를 이용하여 웹 서버 운영자의 비용/노력 부담을 줄일 수 있다.

### 가장 가까운 캐시 서버의 관점
- 콘텐츠 배포 서비스를 사용하는 경우 인터넷 전체에 설치된 다수의 캐시 서버를 이용하는데, 다수가 있는 캐시 서버 중에서 가장 가까운 캐시 서버를 찾아내고, 클라이언트가 여기에 액세스하도록 중재하는 구조가 필요하다.
- DNS 서버가 웹 서버의 IP 주소를 회답할때 가장 가까운 캐시 서버의 IP 주소를 회답하도록 DNS 서버를 세밀하게 설정하는 방법이 있다.
- 클라이언트와 캐시 서버의 거리를 판단하는 방법은 다음과 같다.
  - 캐시 서버의 설치 장소에 있는 라우터에서 경로 정보를 모아온다.
  - 모든 라우터에 대해 경로표를 사용하여 클라이언트측의 DNS 서버까지의 경로 정보를 파악해 대략적인 거리를 계산하고 비교한다.
  - 라우터는 캐시 서버의 설치 장소에 있고 클라이언트측의 DNS 서버도 클라이언트와 같은 장소에 있다고 가정하면 어떤 캐시 서버가 가장 가까운 위치에 있는지 알 수 있다. (실제로 클라이언트측의 DNS 서버는 반드시 클라이언트와 같은 장소에 있는 것이 아니지만, 웬만큼 정확하게 거리 측정 가능)

### 리피터용 서버로 액세스 대상을 분배한다
- 가장 가까운 캐시 서버에 액세스하는 방법은 한 가지가 더 있는데, 'Location'이라는 HTTP 헤더 필드를 사용하는 것이다. (**리다이렉트**)
- 리다이렉트용 서버를 웹 서버측의 DNS 서버에 등록해, 리다이렉트용 서버에 라우터에서 모은 경로 정보들을 통해 가장 가까운 캐시 서버를 찾아 캐시 서버를 나타내는 Location 헤더를 붙영 응답을 돌려보내고, 응답을 받은 클라이언트는 캐시 서버에 다시 액세스한다.
- 리다이렉트의 HTTP 메시지의 대화가 증가해 오버해드가 많지만 DNS 설정보다, HTTP 메시지의 송신처 IP 주소를 바탕으로 거리를 판단하므로 정밀도가 높다.
- 패킷의 왕복 시간을 통해 캐시 서버까지의 거리를 계산하여 최적의 캐시 서버에 액세스하도록 하는 스크립트 프로그램을 내장한 페이지를 반송해, 클라이언트 스스로 최적의 캐시 서버를 판단하고, 여기에 액세스하도록 할 수도 있다.

### 캐시 내용의 갱신 방법에서 성능의 차이가 난다
- 캐시는 최초의 액세스 동작이 효율적이지 않고 두 번째 이후의 액세스에서도 원래 데이터를 가진 웹 서버에 갱신된 내용의 유무를 확인해야 하는 동작이 있어, 이것이 혼잡하게 뒤얽히면 응답 시간이 악화된다.
- 개선을 위해 웹 서버에서 원래 데이터를 갱신할 경우 이것을 즉시 캐시 서버에 반영해야 하고, 캐시의 데이터는 항상 최신의 상태를 유지할 수 있어 원래 데이터의 갱신을 확인할 필요가 없고, 최초의 책세스 동작에도 캐시 데이터를 이용할 수 있다.
- 콘텐츠 배포 서비스에서 이용하는 캐시 서버에는 이러한 대책이 내장되어 있다.
- 웹 페이지는 동적으로 페이지를 만드는 경우도 있는데 이런 경우는 캐시 서버에 페이지 전체를 저장하지 않고, 정적인 부분만 캐시에 저쟝해야 한다.

---
방화벽이나 프록시 서버, 캐시 서버 등 웹 서버의 바로 앞에는 다양한 서버가 있는데, 리퀘스트는 최종적으로 이곳을 통과하여 웹 서버게 도착한다.  
웹 서버는 리퀘스트를 받고 요구 내용을 조사하여 요구에 따라 응답 메시지를 만들어 반송한다.
